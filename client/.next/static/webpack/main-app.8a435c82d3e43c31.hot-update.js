"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/app-find-source-map-url.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findSourceMapURL\", ({\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n}));\nconst basePath =  false || '';\nconst pathname = \"\" + basePath + \"/__nextjs_source-map\";\nconst findSourceMapURL =  true ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return \"\" + filename + \".map\";\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-find-source-map-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7b0RBR2FBOzs7ZUFBQUE7OztBQUhiLE1BQU1DLFdBQVdDLE1BQWtDLElBQUk7QUFDdkQsTUFBTUcsV0FBWSxLQUFFSixXQUFTO0FBRXRCLE1BQU1ELG1CQUNYRSxLQUFvQixHQUNoQixTQUFTRixpQkFBaUJPLFFBQWdCO0lBQ3hDLElBQUlBLGFBQWEsSUFBSTtRQUNuQixPQUFPO0lBQ1Q7SUFFQSxJQUNFQSxTQUFTQyxVQUFVLENBQUNDLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTSxLQUM1Q0osU0FBU0ssUUFBUSxDQUFDLGtCQUNsQjtRQUNBLGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLG1FQUFtRTtRQUNuRSxxRUFBcUU7UUFDckUsNERBQTREO1FBQzVELDZDQUE2QztRQUM3QyxPQUFRLEtBQUVMLFdBQVM7SUFDckI7SUFFQSxNQUFNTSxNQUFNLElBQUlDLElBQUlULFVBQVVJLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTTtJQUN0REUsSUFBSUUsWUFBWSxDQUFDQyxHQUFHLENBQUMsWUFBWVQ7SUFFakMsT0FBT00sSUFBSUksSUFBSTtBQUNqQixJQUNBQyxDQUFTQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWtpX1xcT25lRHJpdmVcXHNyY1xcY2xpZW50XFxhcHAtZmluZC1zb3VyY2UtbWFwLXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJydcbmNvbnN0IHBhdGhuYW1lID0gYCR7YmFzZVBhdGh9L19fbmV4dGpzX3NvdXJjZS1tYXBgXG5cbmV4cG9ydCBjb25zdCBmaW5kU291cmNlTWFwVVJMID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGZ1bmN0aW9uIGZpbmRTb3VyY2VNYXBVUkwoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbikgJiZcbiAgICAgICAgICBmaWxlbmFtZS5pbmNsdWRlcygnL19uZXh0L3N0YXRpYycpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXF1ZXN0IGZvciBhIGNsaWVudCBjaHVuay4gVGhpcyBjYW4gb25seSBoYXBwZW4gd2hlblxuICAgICAgICAgIC8vIHVzaW5nIFR1cmJvcGFjay4gSW4gdGhpcyBjYXNlLCBzaW5jZSB3ZSBjb250cm9sIGhvdyB0aG9zZSBzb3VyY2VcbiAgICAgICAgICAvLyBtYXBzIGFyZSBnZW5lcmF0ZWQsIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXQgdGhlIHNvdXJjZU1hcHBpbmdVUkxcbiAgICAgICAgICAvLyBpcyByZWxhdGl2ZSB0byB0aGUgZmlsZW5hbWUsIHdpdGggYW4gYWRkZWQgYC5tYXBgIGV4dGVuc2lvbi4gVGhlXG4gICAgICAgICAgLy8gYnJvd3NlciBjYW4ganVzdCByZXF1ZXN0IHRoaXMgZmlsZSwgYW5kIGl0IGdldHMgc2VydmVkIHRocm91Z2ggdGhlXG4gICAgICAgICAgLy8gbm9ybWFsIGRldiBzZXJ2ZXIsIHdpdGhvdXQgdGhlIG5lZWQgdG8gcm91dGUgdGhpcyB0aHJvdWdoXG4gICAgICAgICAgLy8gdGhlIGAvX19uZXh0anNfc291cmNlLW1hcGAgZGV2IG1pZGRsZXdhcmUuXG4gICAgICAgICAgcmV0dXJuIGAke2ZpbGVuYW1lfS5tYXBgXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lLCBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdmaWxlbmFtZScsIGZpbGVuYW1lKVxuXG4gICAgICAgIHJldHVybiB1cmwuaHJlZlxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkXG4iXSwibmFtZXMiOlsiZmluZFNvdXJjZU1hcFVSTCIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRobmFtZSIsIk5PREVfRU5WIiwiZmlsZW5hbWUiLCJzdGFydHNXaXRoIiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImluY2x1ZGVzIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiaHJlZiIsInVuZGVmaW5lZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-index.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/client/app-index.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// imports polyfill from `@next/polyfill-module` after build.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hydrate\", ({\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/polyfill-module.js\");\n__webpack_require__(/*! ./components/globals/patch-console */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/patch-console.js\");\n__webpack_require__(/*! ./components/globals/handle-global-errors */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/handle-global-errors.js\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _client1 = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _errorboundarycallbacks = __webpack_require__(/*! ./react-client-callbacks/error-boundary-callbacks */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\");\nconst _appcallserver = __webpack_require__(/*! ./app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ./app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _actionqueue = __webpack_require__(/*! ../shared/lib/router/action-queue */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/action-queue.js\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./components/app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\"));\nconst _createinitialrouterstate = __webpack_require__(/*! ./components/router-reducer/create-initial-router-state */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _appbuildid = __webpack_require__(/*! ./app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\nconst _iserrorthrownwhilerenderingrsc = __webpack_require__(/*! ./lib/is-error-thrown-while-rendering-rsc */ \"(app-pages-browser)/./node_modules/next/dist/client/lib/is-error-thrown-while-rendering-rsc.js\");\n/// <reference types=\"react-dom/experimental\" />\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n_c = DOMContentLoaded;\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nconst initialServerResponse = (0, _client1.createFromReadableStream)(readable, {\n    callServer: _appcallserver.callServer,\n    findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n});\n// React overrides `.then` and doesn't return a new promise chain,\n// so we wrap the action queue in a promise to ensure that its value\n// is defined when the promise resolves.\n// https://github.com/facebook/react/blob/163365a07872337e04826c4f501565d43dbd2fd4/packages/react-client/src/ReactFlightClient.js#L189-L190\nconst pendingActionQueue = new Promise((resolve, reject)=>{\n    initialServerResponse.then((initialRSCPayload)=>{\n        // setAppBuildId should be called only once, during JS initialization\n        // and before any components have hydrated.\n        (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n        resolve((0, _actionqueue.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n            initialFlightData: initialRSCPayload.f,\n            initialCanonicalUrlParts: initialRSCPayload.c,\n            initialParallelRoutes: new Map(),\n            location: window.location,\n            couldBeIntercepted: initialRSCPayload.i,\n            postponed: initialRSCPayload.s,\n            prerendered: initialRSCPayload.S\n        })));\n    }, (err)=>reject(err));\n});\nfunction ServerRoot() {\n    const initialRSCPayload = (0, _react.use)(initialServerResponse);\n    const actionQueue = (0, _react.use)(pendingActionQueue);\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorComponentAndStyles: initialRSCPayload.G,\n        assetPrefix: initialRSCPayload.p\n    });\n    if ( true && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\n_c1 = ServerRoot;\nconst StrictModeIfEnabled =  true ? _react.default.StrictMode : 0;\nfunction Root(param) {\n    let { children } = param;\n    if (false) {}\n    return children;\n}\n_c2 = Root;\nconst reactRootOptions = {\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nfunction hydrate() {\n    var _window___next_root_layout_missing_tags;\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {})\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__' || !!((_window___next_root_layout_missing_tags = window.__next_root_layout_missing_tags) == null ? void 0 : _window___next_root_layout_missing_tags.length)) {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if ( true && (0, _iserrorthrownwhilerenderingrsc.shouldRenderRootLevelErrorOverlay)()) {\n            const { createRootLevelDevOverlayElement } = __webpack_require__(/*! ./components/react-dev-overlay/app/client-entry */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/client-entry.js\");\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = createRootLevelDevOverlayElement(element);\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const { linkGc } = __webpack_require__(/*! ./app-link-gc */ \"(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"DOMContentLoaded\");\n$RefreshReg$(_c1, \"ServerRoot\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2REFBNkQ7Ozs7OzJDQWdQN0NBOzs7ZUFBQUE7Ozs7OztvQkEvT1Q7b0JBRUE7b0JBQ0E7NkVBRW9COzZFQUNBO3FDQUVjOzZEQUNOO2dEQUNBO29EQUk1QjsyQ0FDb0I7aURBQ007eUNBSTFCO2dGQUNlO3NEQUVtQjsyREFDTjt3Q0FDTDs0REFDb0I7QUFFbEQsZ0RBQWdEO0FBRWhELE1BQU1DLGFBQXFDQztBQUUzQyxNQUFNQyxVQUFVLElBQUlDO0FBRXBCLElBQUlDLDBCQUErREM7QUFDbkUsSUFBSUMsMEJBQ0ZEO0FBQ0YsSUFBSUUsMEJBQTBCO0FBQzlCLElBQUlDLDJCQUEyQjtBQUUvQixJQUFJQyx1QkFBbUM7QUFtQnZDLFNBQVNDLHVCQUF1QkMsR0FBa0I7SUFDaEQsSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ2hCUCwwQkFBMEIsRUFBRTtJQUM5QixPQUFPLElBQUlPLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUN2QixJQUFJLENBQUNQLHlCQUNILE1BQU0scUJBQThELENBQTlELElBQUlRLE1BQU0sc0RBQVY7bUJBQUE7d0JBQUE7MEJBQUE7UUFBNkQ7UUFFckUsSUFBSU4seUJBQXlCO1lBQzNCQSx3QkFBd0JPLE9BQU8sQ0FBQ1gsUUFBUVksTUFBTSxDQUFDSCxHQUFHLENBQUMsRUFBRTtRQUN2RCxPQUFPO1lBQ0xQLHdCQUF3QlcsSUFBSSxDQUFDSixHQUFHLENBQUMsRUFBRTtRQUNyQztJQUNGLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCRix1QkFBdUJFLEdBQUcsQ0FBQyxFQUFFO0lBQy9CLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCLElBQUksQ0FBQ1AseUJBQ0gsTUFBTSxxQkFBOEQsQ0FBOUQsSUFBSVEsTUFB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QixpQ0FBQUEsa0JBQWtCLENBQUNDLFFBQVE7WUFBQ2xCLE9BQU87Z0JBQUVtQixRQUFRO1lBQUs7c0JBQ2pELG1DQUFDYixNQUFBQTswQkFDQyxtQ0FBQ3BCLFlBQUFBLENBQUFBOzs7O0lBTVQsSUFDRXJFLFNBQVN1RyxlQUFlLENBQUNDLEVBQUUsS0FBSyxvQkFDaEMsQ0FBQyxHQUFDMUMsMENBQUFBLE9BQU8yQywrQkFBQUEsS0FBK0IsZ0JBQXRDM0Msd0NBQXdDM0MsTUFBQUEsR0FDMUM7UUFDQSxJQUFJdUYsVUFBVVA7UUFDZCw4REFBOEQ7UUFDOUQsSUFwSjZCLEtBcUpQLElBQ3BCUSxDQUFBQSxHQUFBQSxnQ0FBQUEsaUNBQUFBLEtBQ0E7WUFDQSxNQUFNLEVBQUVDLGdDQUFnQyxFQUFFLEdBQ3hDQyxtQkFBT0EsQ0FBQyw2SkFBaUQ7WUFFM0Qsa0ZBQWtGO1lBQ2xGSCxVQUFVRSxpQ0FBaUNGO1FBQzdDO1FBRUFJLFFBQUFBLE9BQWMsQ0FBQ0MsVUFBVSxDQUFDaEgsWUFBWWdHLGtCQUFrQmlCLE1BQU0sQ0FBQ047SUFDakUsT0FBTztRQUNMcEIsT0FBQUEsT0FBSyxDQUFDMkIsZUFBZSxDQUFDO1lBQ3BCSCxRQUFBQSxPQUFjLENBQUNJLFdBQVcsQ0FBQ25ILFlBQVlvRyxTQUFTO2dCQUM5QyxHQUFHSixnQkFBZ0I7Z0JBQ25Cb0IsV0FBVzNHO1lBQ2I7UUFDRjtJQUNGO0lBRUEseUVBQXlFO0lBQ3pFLElBMUsrQixJQTBLUCxFQUFtQjtRQUN6QyxNQUFNLEVBQUU0RyxNQUFNLEVBQUUsR0FDZFAsbUJBQU9BLENBQUMseUZBQWU7UUFDekJPO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWtpX1xcT25lRHJpdmVcXHNyY1xcY2xpZW50XFxhcHAtaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydHMgcG9seWZpbGwgZnJvbSBgQG5leHQvcG9seWZpbGwtbW9kdWxlYCBhZnRlciBidWlsZC5cbmltcG9ydCAnLi4vYnVpbGQvcG9seWZpbGxzL3BvbHlmaWxsLW1vZHVsZSdcblxuaW1wb3J0ICcuL2NvbXBvbmVudHMvZ2xvYmFscy9wYXRjaC1jb25zb2xlJ1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvZ2xvYmFscy9oYW5kbGUtZ2xvYmFsLWVycm9ycydcblxuaW1wb3J0IFJlYWN0RE9NQ2xpZW50IGZyb20gJ3JlYWN0LWRvbS9jbGllbnQnXG5pbXBvcnQgUmVhY3QsIHsgdXNlIH0gZnJvbSAncmVhY3QnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IG9uUmVjb3ZlcmFibGVFcnJvciB9IGZyb20gJy4vcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9vbi1yZWNvdmVyYWJsZS1lcnJvcidcbmltcG9ydCB7XG4gIG9uQ2F1Z2h0RXJyb3IsXG4gIG9uVW5jYXVnaHRFcnJvcixcbn0gZnJvbSAnLi9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL2Vycm9yLWJvdW5kYXJ5LWNhbGxiYWNrcydcbmltcG9ydCB7IGNhbGxTZXJ2ZXIgfSBmcm9tICcuL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuL2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsJ1xuaW1wb3J0IHtcbiAgdHlwZSBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci9hY3Rpb24tcXVldWUnXG5pbXBvcnQgQXBwUm91dGVyIGZyb20gJy4vY29tcG9uZW50cy9hcHAtcm91dGVyJ1xuaW1wb3J0IHR5cGUgeyBJbml0aWFsUlNDUGF5bG9hZCB9IGZyb20gJy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIH0gZnJvbSAnLi9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZSdcbmltcG9ydCB7IE1pc3NpbmdTbG90Q29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgc2V0QXBwQnVpbGRJZCB9IGZyb20gJy4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHsgc2hvdWxkUmVuZGVyUm9vdExldmVsRXJyb3JPdmVybGF5IH0gZnJvbSAnLi9saWIvaXMtZXJyb3ItdGhyb3duLXdoaWxlLXJlbmRlcmluZy1yc2MnXG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwicmVhY3QtZG9tL2V4cGVyaW1lbnRhbFwiIC8+XG5cbmNvbnN0IGFwcEVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnQgPSBkb2N1bWVudFxuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyOiAoc3RyaW5nIHwgVWludDhBcnJheSlbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHwgdW5kZWZpbmVkID1cbiAgdW5kZWZpbmVkXG5sZXQgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgPSBmYWxzZVxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCA9IGZhbHNlXG5cbmxldCBpbml0aWFsRm9ybVN0YXRlRGF0YTogbnVsbCB8IGFueSA9IG51bGxcblxudHlwZSBGbGlnaHRTZWdtZW50ID1cbiAgfCBbaXNCb290U3RyYXA6IDBdXG4gIHwgW2lzTm90Qm9vdHN0cmFwOiAxLCByZXNwb25zZVBhcnRpYWw6IHN0cmluZ11cbiAgfCBbaXNGb3JtU3RhdGU6IDIsIGZvcm1TdGF0ZTogYW55XVxuICB8IFtpc0JpbmFyeTogMywgcmVzcG9uc2VCYXNlNjRQYXJ0aWFsOiBzdHJpbmddXG5cbnR5cGUgTmV4dEZsaWdodCA9IE9taXQ8QXJyYXk8RmxpZ2h0U2VnbWVudD4sICdwdXNoJz4gJiB7XG4gIHB1c2g6IChzZWc6IEZsaWdodFNlZ21lbnQpID0+IHZvaWRcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBJZiB5b3UncmUgd29ya2luZyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19uZXh0X2Y6IE5leHRGbGlnaHRcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0U2VydmVyRGF0YUNhbGxiYWNrKHNlZzogRmxpZ2h0U2VnbWVudCk6IHZvaWQge1xuICBpZiAoc2VnWzBdID09PSAwKSB7XG4gICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIgPSBbXVxuICB9IGVsc2UgaWYgKHNlZ1swXSA9PT0gMSkge1xuICAgIGlmICghaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2VydmVyIGRhdGE6IG1pc3NpbmcgYm9vdHN0cmFwIHNjcmlwdC4nKVxuXG4gICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyKSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKHNlZ1sxXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyLnB1c2goc2VnWzFdKVxuICAgIH1cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDIpIHtcbiAgICBpbml0aWFsRm9ybVN0YXRlRGF0YSA9IHNlZ1sxXVxuICB9IGVsc2UgaWYgKHNlZ1swXSA9PT0gMykge1xuICAgIGlmICghaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2VydmVyIGRhdGE6IG1pc3NpbmcgYm9vdHN0cmFwIHNjcmlwdC4nKVxuXG4gICAgLy8gRGVjb2RlIHRoZSBiYXNlNjQgc3RyaW5nIGJhY2sgdG8gYmluYXJ5IGRhdGEuXG4gICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihzZWdbMV0pXG4gICAgY29uc3QgZGVjb2RlZENodW5rID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVjb2RlZENodW5rW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSlcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIpIHtcbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyLmVucXVldWUoZGVjb2RlZENodW5rKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5wdXNoKGRlY29kZWRDaHVuaylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJlYW1FcnJvck9yVW5maW5pc2hlZChjdHI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpIHtcbiAgLy8gSWYgYGRlc2lyZWRTaXplYCBpcyBudWxsLCBpdCBtZWFucyB0aGUgc3RyZWFtIGlzIGNsb3NlZCBvciBlcnJvcmVkLiBJZiBpdCBpcyBsb3dlciB0aGFuIDAsIHRoZSBzdHJlYW0gaXMgc3RpbGwgdW5maW5pc2hlZC5cbiAgcmV0dXJuIGN0ci5kZXNpcmVkU2l6ZSA9PT0gbnVsbCB8fCBjdHIuZGVzaXJlZFNpemUgPCAwXG59XG5cbi8vIFRoZXJlIG1pZ2h0IGJlIHJhY2UgY29uZGl0aW9ucyBiZXR3ZWVuIGBuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyYCBhbmRcbi8vIGBET01Db250ZW50TG9hZGVkYC4gVGhlIGZvcm1lciB3aWxsIGJlIGNhbGxlZCB3aGVuIFJlYWN0IHN0YXJ0cyB0byBoeWRyYXRlXG4vLyB0aGUgcm9vdCwgdGhlIGxhdHRlciB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBET00gaXMgZnVsbHkgbG9hZGVkLlxuLy8gRm9yIHN0cmVhbWluZywgdGhlIGZvcm1lciBpcyBjYWxsZWQgZmlyc3QgZHVlIHRvIHBhcnRpYWwgaHlkcmF0aW9uLlxuLy8gRm9yIG5vbi1zdHJlYW1pbmcsIHRoZSBsYXR0ZXIgY2FuIGJlIGNhbGxlZCBmaXJzdC5cbi8vIEhlbmNlLCB3ZSB1c2UgdHdvIHZhcmlhYmxlcyBgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWRgIGFuZFxuLy8gYGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZGAgdG8gbWFrZSBzdXJlIHRoZSB3cml0ZXIgd2lsbCBiZSBjbG9zZWQgYW5kXG4vLyBgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXJgIHdpbGwgYmUgY2xlYXJlZCBpbiB0aGUgcmlnaHQgdGltZS5cbmZ1bmN0aW9uIG5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXIoY3RyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSB7XG4gIGlmIChpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcikge1xuICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgY3RyLmVucXVldWUodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBlbmNvZGVyLmVuY29kZSh2YWwpIDogdmFsKVxuICAgIH0pXG4gICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkICYmICFpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQpIHtcbiAgICAgIGlmIChpc1N0cmVhbUVycm9yT3JVbmZpbmlzaGVkKGN0cikpIHtcbiAgICAgICAgY3RyLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgY29ubmVjdGlvbiB0byB0aGUgcGFnZSB3YXMgdW5leHBlY3RlZGx5IGNsb3NlZCwgcG9zc2libHkgZHVlIHRvIHRoZSBzdG9wIGJ1dHRvbiBiZWluZyBjbGlja2VkLCBsb3NzIG9mIFdpLUZpLCBvciBhbiB1bnN0YWJsZSBpbnRlcm5ldCBjb25uZWN0aW9uLidcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0ci5jbG9zZSgpXG4gICAgICB9XG4gICAgICBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSB0cnVlXG4gICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyID0gY3RyXG59XG5cbi8vIFdoZW4gYERPTUNvbnRlbnRMb2FkZWRgLCB3ZSBjYW4gY2xvc2UgYWxsIHBlbmRpbmcgd3JpdGVycyB0byBmaW5pc2ggaHlkcmF0aW9uLlxuY29uc3QgRE9NQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyICYmICFpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQpIHtcbiAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5jbG9zZSgpXG4gICAgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkID0gdHJ1ZVxuICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gdW5kZWZpbmVkXG4gIH1cbiAgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgPSB0cnVlXG59XG5cbi8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgRE9NIGlzIGFscmVhZHkgbG9hZGVkLlxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgRE9NQ29udGVudExvYWRlZCwgZmFsc2UpXG59IGVsc2Uge1xuICAvLyBEZWxheWVkIGluIG1hcmNvIHRhc2sgdG8gZW5zdXJlIGl0J3MgZXhlY3V0ZWQgbGF0ZXIgdGhhbiBoeWRyYXRpb25cbiAgc2V0VGltZW91dChET01Db250ZW50TG9hZGVkKVxufVxuXG5jb25zdCBuZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwgPSAoc2VsZi5fX25leHRfZiA9IHNlbGYuX19uZXh0X2YgfHwgW10pXG5uZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwuZm9yRWFjaChuZXh0U2VydmVyRGF0YUNhbGxiYWNrKVxubmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsLnB1c2ggPSBuZXh0U2VydmVyRGF0YUNhbGxiYWNrXG5cbmNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgc3RhcnQoY29udHJvbGxlcikge1xuICAgIG5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXIoY29udHJvbGxlcilcbiAgfSxcbn0pXG5cbmNvbnN0IGluaXRpYWxTZXJ2ZXJSZXNwb25zZSA9IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbTxJbml0aWFsUlNDUGF5bG9hZD4oXG4gIHJlYWRhYmxlLFxuICB7IGNhbGxTZXJ2ZXIsIGZpbmRTb3VyY2VNYXBVUkwgfVxuKVxuXG4vLyBSZWFjdCBvdmVycmlkZXMgYC50aGVuYCBhbmQgZG9lc24ndCByZXR1cm4gYSBuZXcgcHJvbWlzZSBjaGFpbixcbi8vIHNvIHdlIHdyYXAgdGhlIGFjdGlvbiBxdWV1ZSBpbiBhIHByb21pc2UgdG8gZW5zdXJlIHRoYXQgaXRzIHZhbHVlXG4vLyBpcyBkZWZpbmVkIHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi8xNjMzNjVhMDc4NzIzMzdlMDQ4MjZjNGY1MDE1NjVkNDNkYmQyZmQ0L3BhY2thZ2VzL3JlYWN0LWNsaWVudC9zcmMvUmVhY3RGbGlnaHRDbGllbnQuanMjTDE4OS1MMTkwXG5jb25zdCBwZW5kaW5nQWN0aW9uUXVldWU6IFByb21pc2U8QXBwUm91dGVyQWN0aW9uUXVldWU+ID0gbmV3IFByb21pc2UoXG4gIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpbml0aWFsU2VydmVyUmVzcG9uc2UudGhlbihcbiAgICAgIChpbml0aWFsUlNDUGF5bG9hZCkgPT4ge1xuICAgICAgICAvLyBzZXRBcHBCdWlsZElkIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLCBkdXJpbmcgSlMgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgLy8gYW5kIGJlZm9yZSBhbnkgY29tcG9uZW50cyBoYXZlIGh5ZHJhdGVkLlxuICAgICAgICBzZXRBcHBCdWlsZElkKGluaXRpYWxSU0NQYXlsb2FkLmIpXG5cbiAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUoXG4gICAgICAgICAgICBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoe1xuICAgICAgICAgICAgICBpbml0aWFsRmxpZ2h0RGF0YTogaW5pdGlhbFJTQ1BheWxvYWQuZixcbiAgICAgICAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzOiBpbml0aWFsUlNDUGF5bG9hZC5jLFxuICAgICAgICAgICAgICBpbml0aWFsUGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgbG9jYXRpb246IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgICAgICAgY291bGRCZUludGVyY2VwdGVkOiBpbml0aWFsUlNDUGF5bG9hZC5pLFxuICAgICAgICAgICAgICBwb3N0cG9uZWQ6IGluaXRpYWxSU0NQYXlsb2FkLnMsXG4gICAgICAgICAgICAgIHByZXJlbmRlcmVkOiBpbml0aWFsUlNDUGF5bG9hZC5TLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICAoZXJyOiBFcnJvcikgPT4gcmVqZWN0KGVycilcbiAgICApXG4gIH1cbilcblxuZnVuY3Rpb24gU2VydmVyUm9vdCgpOiBSZWFjdC5SZWFjdE5vZGUge1xuICBjb25zdCBpbml0aWFsUlNDUGF5bG9hZCA9IHVzZShpbml0aWFsU2VydmVyUmVzcG9uc2UpXG4gIGNvbnN0IGFjdGlvblF1ZXVlID0gdXNlPEFwcFJvdXRlckFjdGlvblF1ZXVlPihwZW5kaW5nQWN0aW9uUXVldWUpXG5cbiAgY29uc3Qgcm91dGVyID0gKFxuICAgIDxBcHBSb3V0ZXJcbiAgICAgIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX1cbiAgICAgIGdsb2JhbEVycm9yQ29tcG9uZW50QW5kU3R5bGVzPXtpbml0aWFsUlNDUGF5bG9hZC5HfVxuICAgICAgYXNzZXRQcmVmaXg9e2luaXRpYWxSU0NQYXlsb2FkLnB9XG4gICAgLz5cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBpbml0aWFsUlNDUGF5bG9hZC5tKSB7XG4gICAgLy8gV2UgcHJvdmlkZSBtaXNzaW5nIHNsb3QgaW5mb3JtYXRpb24gaW4gYSBjb250ZXh0IHByb3ZpZGVyIG9ubHkgZHVyaW5nIGRldmVsb3BtZW50XG4gICAgLy8gYXMgd2UgbG9nIHNvbWUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWlzc2luZyBzbG90cyBpbiB0aGUgY29uc29sZS5cbiAgICByZXR1cm4gKFxuICAgICAgPE1pc3NpbmdTbG90Q29udGV4dCB2YWx1ZT17aW5pdGlhbFJTQ1BheWxvYWQubX0+XG4gICAgICAgIHtyb3V0ZXJ9XG4gICAgICA8L01pc3NpbmdTbG90Q29udGV4dD5cbiAgICApXG4gIH1cblxuICByZXR1cm4gcm91dGVyXG59XG5cbmNvbnN0IFN0cmljdE1vZGVJZkVuYWJsZWQgPSBwcm9jZXNzLmVudi5fX05FWFRfU1RSSUNUX01PREVfQVBQXG4gID8gUmVhY3QuU3RyaWN0TW9kZVxuICA6IFJlYWN0LkZyYWdtZW50XG5cbmZ1bmN0aW9uIFJvb3QoeyBjaGlsZHJlbiB9OiBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7fT4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWVcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0I/LigpXG4gICAgfSwgW10pXG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuY29uc3QgcmVhY3RSb290T3B0aW9uczogUmVhY3RET01DbGllbnQuUm9vdE9wdGlvbnMgPSB7XG4gIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgb25DYXVnaHRFcnJvcixcbiAgb25VbmNhdWdodEVycm9yLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSgpIHtcbiAgY29uc3QgcmVhY3RFbCA9IChcbiAgICA8U3RyaWN0TW9kZUlmRW5hYmxlZD5cbiAgICAgIDxIZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgYXBwRGlyOiB0cnVlIH19PlxuICAgICAgICA8Um9vdD5cbiAgICAgICAgICA8U2VydmVyUm9vdCAvPlxuICAgICAgICA8L1Jvb3Q+XG4gICAgICA8L0hlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L1N0cmljdE1vZGVJZkVuYWJsZWQ+XG4gIClcblxuICBpZiAoXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmlkID09PSAnX19uZXh0X2Vycm9yX18nIHx8XG4gICAgISF3aW5kb3cuX19uZXh0X3Jvb3RfbGF5b3V0X21pc3NpbmdfdGFncz8ubGVuZ3RoXG4gICkge1xuICAgIGxldCBlbGVtZW50ID0gcmVhY3RFbFxuICAgIC8vIFNlcnZlciByZW5kZXJpbmcgZmFpbGVkLCBmYWxsIGJhY2sgdG8gY2xpZW50LXNpZGUgcmVuZGVyaW5nXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hvdWxkUmVuZGVyUm9vdExldmVsRXJyb3JPdmVybGF5KClcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY3JlYXRlUm9vdExldmVsRGV2T3ZlcmxheUVsZW1lbnQgfSA9XG4gICAgICAgIHJlcXVpcmUoJy4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9hcHAvY2xpZW50LWVudHJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2FwcC9jbGllbnQtZW50cnknKVxuXG4gICAgICAvLyBOb3RlIHRoaXMgd29uJ3QgY2F1c2UgaHlkcmF0aW9uIG1pc21hdGNoIGJlY2F1c2Ugd2UgYXJlIGRvaW5nIENTUiB3L28gaHlkcmF0aW9uXG4gICAgICBlbGVtZW50ID0gY3JlYXRlUm9vdExldmVsRGV2T3ZlcmxheUVsZW1lbnQoZWxlbWVudClcbiAgICB9XG5cbiAgICBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KGFwcEVsZW1lbnQsIHJlYWN0Um9vdE9wdGlvbnMpLnJlbmRlcihlbGVtZW50KVxuICB9IGVsc2Uge1xuICAgIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChhcHBFbGVtZW50LCByZWFjdEVsLCB7XG4gICAgICAgIC4uLnJlYWN0Um9vdE9wdGlvbnMsXG4gICAgICAgIGZvcm1TdGF0ZTogaW5pdGlhbEZvcm1TdGF0ZURhdGEsXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBUT0RPLUFQUDogUmVtb3ZlIHRoaXMgbG9naWMgd2hlbiBGbG9hdCBoYXMgR0MgYnVpbHQtaW4gaW4gZGV2ZWxvcG1lbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBsaW5rR2MgfSA9XG4gICAgICByZXF1aXJlKCcuL2FwcC1saW5rLWdjJykgYXMgdHlwZW9mIGltcG9ydCgnLi9hcHAtbGluay1nYycpXG4gICAgbGlua0djKClcbiAgfVxufVxuIl0sIm5hbWVzIjpbImh5ZHJhdGUiLCJhcHBFbGVtZW50IiwiZG9jdW1lbnQiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciIsInVuZGVmaW5lZCIsImluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyIiwiaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQiLCJpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQiLCJpbml0aWFsRm9ybVN0YXRlRGF0YSIsIm5leHRTZXJ2ZXJEYXRhQ2FsbGJhY2siLCJzZWciLCJFcnJvciIsImVucXVldWUiLCJlbmNvZGUiLCJwdXNoIiwiYmluYXJ5U3RyaW5nIiwiYXRvYiIsImRlY29kZWRDaHVuayIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGVBdCIsImlzU3RyZWFtRXJyb3JPclVuZmluaXNoZWQiLCJjdHIiLCJkZXNpcmVkU2l6ZSIsIm5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXIiLCJmb3JFYWNoIiwidmFsIiwiZXJyb3IiLCJjbG9zZSIsIkRPTUNvbnRlbnRMb2FkZWQiLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJuZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwiLCJzZWxmIiwiX19uZXh0X2YiLCJyZWFkYWJsZSIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyIiwiaW5pdGlhbFNlcnZlclJlc3BvbnNlIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIiwiY2FsbFNlcnZlciIsImZpbmRTb3VyY2VNYXBVUkwiLCJwZW5kaW5nQWN0aW9uUXVldWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJpbml0aWFsUlNDUGF5bG9hZCIsInNldEFwcEJ1aWxkSWQiLCJiIiwiY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIiwiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIiwiaW5pdGlhbEZsaWdodERhdGEiLCJmIiwiaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzIiwiYyIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsIk1hcCIsImxvY2F0aW9uIiwid2luZG93IiwiY291bGRCZUludGVyY2VwdGVkIiwicG9zdHBvbmVkIiwicyIsInByZXJlbmRlcmVkIiwiUyIsImVyciIsIlNlcnZlclJvb3QiLCJ1c2UiLCJhY3Rpb25RdWV1ZSIsInJvdXRlciIsIkFwcFJvdXRlciIsImdsb2JhbEVycm9yQ29tcG9uZW50QW5kU3R5bGVzIiwiRyIsImFzc2V0UHJlZml4IiwicCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm0iLCJNaXNzaW5nU2xvdENvbnRleHQiLCJ2YWx1ZSIsIlN0cmljdE1vZGVJZkVuYWJsZWQiLCJfX05FWFRfU1RSSUNUX01PREVfQVBQIiwiUmVhY3QiLCJTdHJpY3RNb2RlIiwiRnJhZ21lbnQiLCJSb290IiwiY2hpbGRyZW4iLCJfX05FWFRfVEVTVF9NT0RFIiwidXNlRWZmZWN0IiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0NCIiwicmVhY3RSb290T3B0aW9ucyIsIm9uUmVjb3ZlcmFibGVFcnJvciIsIm9uQ2F1Z2h0RXJyb3IiLCJvblVuY2F1Z2h0RXJyb3IiLCJyZWFjdEVsIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJhcHBEaXIiLCJkb2N1bWVudEVsZW1lbnQiLCJpZCIsIl9fbmV4dF9yb290X2xheW91dF9taXNzaW5nX3RhZ3MiLCJlbGVtZW50Iiwic2hvdWxkUmVuZGVyUm9vdExldmVsRXJyb3JPdmVybGF5IiwiY3JlYXRlUm9vdExldmVsRGV2T3ZlcmxheUVsZW1lbnQiLCJyZXF1aXJlIiwiUmVhY3RET01DbGllbnQiLCJjcmVhdGVSb290IiwicmVuZGVyIiwic3RhcnRUcmFuc2l0aW9uIiwiaHlkcmF0ZVJvb3QiLCJmb3JtU3RhdGUiLCJsaW5rR2MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/app-link-gc.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"linkGc\", ({\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n}));\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            var _link_dataset_precedence;\n                            const link = node;\n                            if ((_link_dataset_precedence = link.dataset.precedence) == null ? void 0 : _link_dataset_precedence.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            var _otherLink_dataset_precedence;\n                                            if ((_otherLink_dataset_precedence = otherLink.dataset.precedence) == null ? void 0 : _otherLink_dataset_precedence.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector('link[rel=\"preload\"][as=\"style\"][href=\"' + otherHref + '\"]');\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1saW5rLWdjLmpzIiwibWFwcGluZ3MiOiI7Ozs7MENBQWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQTtJQUNkLHlFQUF5RTtJQUN6RSxJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNRyxXQUFXLENBQUNDO1lBQ2hCLEtBQUssTUFBTUMsWUFBWUQsYUFBYztnQkFDbkMsSUFBSUMsU0FBU0MsSUFBSSxLQUFLLGFBQWE7b0JBQ2pDLEtBQUssTUFBTUMsUUFBUUYsU0FBU0csVUFBVSxDQUFFO3dCQUN0QyxJQUNFLGFBQWFELFFBQ1pBLEtBQXlCRSxPQUFPLEtBQUssUUFDdEM7Z0NBRUlDOzRCQURKLE1BQU1BLE9BQU9IOzRCQUNiLEtBQUlHLDJCQUFBQSxLQUFLQyxPQUFPLENBQUNDLFVBQUFBLEtBQVUsZ0JBQXZCRix5QkFBeUJHLFVBQVUsQ0FBQyxTQUFTO2dDQUMvQyxNQUFNQyxPQUFPSixLQUFLSyxZQUFZLENBQUM7Z0NBQy9CLElBQUlELE1BQU07b0NBQ1IsTUFBTSxDQUFDRSxVQUFVQyxRQUFRLEdBQUdILEtBQUtJLEtBQUssQ0FBQyxPQUFPO29DQUM5QyxJQUFJRCxTQUFTO3dDQUNYLE1BQU1FLGdCQUFnQkMsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO3dDQUM1QyxNQUFNQyxXQUFXOytDQUNaQyxTQUFTQyxnQkFBZ0IsQ0FDMUIsaUJBQWlCVCxXQUFXOzRDQUU5QixrRUFBa0U7NENBQ2xFLHFEQUFxRDsrQ0FDbERRLFNBQVNDLGdCQUFnQixDQUMxQixpQkFDR1QsQ0FBQUEsU0FBU0gsVUFBVSxDQUFDTSxpQkFDakJILFNBQVNVLEtBQUssQ0FBQ1AsY0FBY1EsTUFBTSxJQUNuQ1IsZ0JBQWdCSCxRQUFBQSxDQUFPLEdBQzNCO3lDQUVMO3dDQUVELEtBQUssTUFBTVksYUFBYUwsU0FBVTtnREFDNUJLOzRDQUFKLEtBQUlBLGdDQUFBQSxVQUFVakIsT0FBTyxDQUFDQyxVQUFBQSxLQUFVLGdCQUE1QmdCLDhCQUE4QmYsVUFBVSxDQUFDLFNBQVM7Z0RBQ3BELE1BQU1nQixZQUFZRCxVQUFVYixZQUFZLENBQUM7Z0RBQ3pDLElBQUljLFdBQVc7b0RBQ2IsTUFBTSxHQUFHQyxhQUFhLEdBQUdELFVBQVVYLEtBQUssQ0FBQyxPQUFPO29EQUNoRCxJQUFJLENBQUNZLGdCQUFnQixDQUFDQSxlQUFlLENBQUNiLFNBQVM7d0RBQzdDLG9EQUFvRDt3REFDcEQsbURBQW1EO3dEQUNuRCxvREFBb0Q7d0RBQ3BELG1EQUFtRDt3REFDbkRjLFdBQVc7NERBQ1RILFVBQVVJLE1BQU07d0RBQ2xCLEdBQUc7d0RBQ0gsTUFBTUMsY0FBY1QsU0FBU1UsYUFBYSxDQUN2QywyQ0FBd0NMLFlBQVU7d0RBRXJELElBQUlJLGFBQWE7NERBQ2ZBLFlBQVlELE1BQU07d0RBQ3BCO29EQUNGO2dEQUNGOzRDQUNGO3dDQUNGO29DQUNGO2dDQUNGOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDhEQUE4RDtRQUM5RCxNQUFNRyxXQUFXLElBQUlDLGlCQUFpQmpDO1FBQ3RDZ0MsU0FBU0UsT0FBTyxDQUFDYixTQUFTYyxJQUFJLEVBQUU7WUFDOUJDLFdBQVc7UUFDYjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWlraV9cXE9uZURyaXZlXFxzcmNcXGNsaWVudFxcYXBwLWxpbmstZ2MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGxpbmtHYygpIHtcbiAgLy8gVE9ETy1BUFA6IFJlbW92ZSB0aGlzIGxvZ2ljIHdoZW4gRmxvYXQgaGFzIEdDIGJ1aWx0LWluIGluIGRldmVsb3BtZW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKG11dGF0aW9uTGlzdDogTXV0YXRpb25SZWNvcmRbXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbkxpc3QpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgJ3RhZ05hbWUnIGluIG5vZGUgJiZcbiAgICAgICAgICAgICAgKG5vZGUgYXMgSFRNTExpbmtFbGVtZW50KS50YWdOYW1lID09PSAnTElOSydcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBsaW5rID0gbm9kZSBhcyBIVE1MTGlua0VsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGxpbmsuZGF0YXNldC5wcmVjZWRlbmNlPy5zdGFydHNXaXRoKCduZXh0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBbcmVzb3VyY2UsIHZlcnNpb25dID0gaHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbExpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgKyByZXNvdXJjZSArICdcIl0nXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHJlc291cmNlIGlzIGEgZnVsbCBVUkwgb3Igb25seSBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYWx0ZXJuYXRpdmUgaHJlZiBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzb3VyY2Uuc3RhcnRzV2l0aChjdXJyZW50T3JpZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb3VyY2Uuc2xpY2UoY3VycmVudE9yaWdpbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50T3JpZ2luICsgcmVzb3VyY2UpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiXSdcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBdIGFzIEhUTUxMaW5rRWxlbWVudFtdXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvdGhlckxpbmsgb2YgYWxsTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJMaW5rLmRhdGFzZXQucHJlY2VkZW5jZT8uc3RhcnRzV2l0aCgnbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckhyZWYgPSBvdGhlckxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgb3RoZXJWZXJzaW9uXSA9IG90aGVySHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlclZlcnNpb24gfHwgK290aGVyVmVyc2lvbiA8ICt2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJlbW92YWwgb2YgdGhlIHN0eWxlc2hlZXQgdG8gYXZvaWQgRk9VQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlZCBieSBgQGZvbnQtZmFjZWAgcnVsZXMsIGFzIHRoZXkgc2VlbSB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY291cGxlIG9mIHRpY2tzIGRlbGF5ZWQgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgYmVpbmcgc3dhcHBlZCBldmVuIGlmIHRoZSBmb250IGlzIGNhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTGluay5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZExpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdW2hyZWY9XCIke290aGVySHJlZn1cIl1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkTGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZExpbmsucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgbGlua2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImxpbmtHYyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNhbGxiYWNrIiwibXV0YXRpb25MaXN0IiwibXV0YXRpb24iLCJ0eXBlIiwibm9kZSIsImFkZGVkTm9kZXMiLCJ0YWdOYW1lIiwibGluayIsImRhdGFzZXQiLCJwcmVjZWRlbmNlIiwic3RhcnRzV2l0aCIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJyZXNvdXJjZSIsInZlcnNpb24iLCJzcGxpdCIsImN1cnJlbnRPcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImFsbExpbmtzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2xpY2UiLCJsZW5ndGgiLCJvdGhlckxpbmsiLCJvdGhlckhyZWYiLCJvdGhlclZlcnNpb24iLCJzZXRUaW1lb3V0IiwicmVtb3ZlIiwicHJlbG9hZExpbmsiLCJxdWVyeVNlbGVjdG9yIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImhlYWQiLCJjaGlsZExpc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEmptyCacheNode: function() {\n        return createEmptyCacheNode;\n    },\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    default: function() {\n        return AppRouter;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _usereducer = __webpack_require__(/*! ./use-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-reducer.js\");\nconst _errorboundary = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\"));\nconst _isbot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _approuterannouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-announcer.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _findheadincache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _removebasepath = __webpack_require__(/*! ../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _computechangedpath = __webpack_require__(/*! ./router-reducer/compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _navfailurehandler = __webpack_require__(/*! ./nav-failure-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/nav-failure-handler.js\");\nconst _appcallserver = __webpack_require__(/*! ../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ./redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./router-reducer/reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst globalMutable = {};\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (true) {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\nfunction HistoryUpdater(param) {\n    let { appRouterState } = param;\n    (0, _react.useInsertionEffect)(()=>{\n        if (false) {}\n        const { tree, pushRef, canonicalUrl } = appRouterState;\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: tree\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        if (false) {}\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\n_c = HistoryUpdater;\nfunction createEmptyCacheNode() {\n    return {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null\n    };\n}\n/**\n * Server response that only patches the cache and tree.\n */ function useChangeByServerResponse(dispatch) {\n    return (0, _react.useCallback)((param)=>{\n        let { previousTree, serverResponse } = param;\n        (0, _react.startTransition)(()=>{\n            dispatch({\n                type: _routerreducertypes.ACTION_SERVER_PATCH,\n                previousTree,\n                serverResponse\n            });\n        });\n    }, [\n        dispatch\n    ]);\n}\nfunction useNavigate(dispatch) {\n    return (0, _react.useCallback)((href, navigateType, shouldScroll)=>{\n        const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n        if (false) {}\n        return dispatch({\n            type: _routerreducertypes.ACTION_NAVIGATE,\n            url,\n            isExternalUrl: isExternalURL(url),\n            locationSearch: location.search,\n            shouldScroll: shouldScroll != null ? shouldScroll : true,\n            navigateType,\n            allowAliasing: true\n        });\n    }, [\n        dispatch\n    ]);\n}\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState == null ? void 0 : currentState.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head(param) {\n    let { headCacheNode } = param;\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n_c1 = Head;\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    _s();\n    let { actionQueue, assetPrefix, globalError } = param;\n    const [state, dispatch] = (0, _usereducer.useReducer)(actionQueue);\n    const { canonicalUrl } = (0, _usereducer.useUnwrapState)(state);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    const changeByServerResponse = useChangeByServerResponse(dispatch);\n    const navigate = useNavigate(dispatch);\n    (0, _appcallserver.useServerActionDispatcher)(dispatch);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ const appRouter = (0, _react.useMemo)(()=>{\n        const routerInstance = {\n            back: ()=>window.history.back(),\n            forward: ()=>window.history.forward(),\n            prefetch:  false ? // cache. So we don't need to dispatch an action.\n            0 : (href, options)=>{\n                // Use the old prefetch implementation.\n                const url = createPrefetchURL(href);\n                if (url !== null) {\n                    var _options_kind;\n                    // The prefetch reducer doesn't actually update any state or\n                    // trigger a rerender. It just writes to a mutable cache. So we\n                    // shouldn't bother calling setState/dispatch; we can just re-run\n                    // the reducer directly using the current state.\n                    // TODO: Refactor this away from a \"reducer\" so it's\n                    // less confusing.\n                    (0, _prefetchreducer.prefetchReducer)(actionQueue.state, {\n                        type: _routerreducertypes.ACTION_PREFETCH,\n                        url,\n                        kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL\n                    });\n                }\n            },\n            replace: (href, options)=>{\n                if (options === void 0) options = {};\n                (0, _react.startTransition)(()=>{\n                    var _options_scroll;\n                    navigate(href, 'replace', (_options_scroll = options.scroll) != null ? _options_scroll : true);\n                });\n            },\n            push: (href, options)=>{\n                if (options === void 0) options = {};\n                (0, _react.startTransition)(()=>{\n                    var _options_scroll;\n                    navigate(href, 'push', (_options_scroll = options.scroll) != null ? _options_scroll : true);\n                });\n            },\n            refresh: ()=>{\n                (0, _react.startTransition)(()=>{\n                    dispatch({\n                        type: _routerreducertypes.ACTION_REFRESH,\n                        origin: window.location.origin\n                    });\n                });\n            },\n            hmrRefresh: ()=>{\n                if (false) {} else {\n                    (0, _react.startTransition)(()=>{\n                        dispatch({\n                            type: _routerreducertypes.ACTION_HMR_REFRESH,\n                            origin: window.location.origin\n                        });\n                    });\n                }\n            }\n        };\n        return routerInstance;\n    }, [\n        actionQueue,\n        dispatch,\n        navigate\n    ]);\n    (0, _react.useEffect)(()=>{\n        // Exists for debugging purposes. Don't use in application code.\n        if (window.next) {\n            window.next.router = appRouter;\n        }\n    }, [\n        appRouter\n    ]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const { cache, prefetchCache, tree } = (0, _usereducer.useUnwrapState)(state);\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: appRouter,\n                cache,\n                prefetchCache,\n                tree\n            };\n        }, [\n            appRouter,\n            cache,\n            prefetchCache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            var _window_history_state;\n            if (!event.persisted || !((_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            dispatch({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, [\n        dispatch\n    ]);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    appRouter.push(url, {});\n                } else {\n                    appRouter.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, [\n        appRouter\n    ]);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = (0, _usereducer.useUnwrapState)(state);\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location1 = window.location;\n            if (pushRef.pendingPush) {\n                location1.assign(canonicalUrl);\n            } else {\n                location1.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        (0, _react.use)(_unresolvedthenable.unresolvedThenable);\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            var _window_history_state;\n            const href = window.location.href;\n            const tree = (_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                dispatch({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url != null ? url : href, href),\n                    tree\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                dispatch({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(window.location.href),\n                    tree: event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n                });\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, [\n        dispatch\n    ]);\n    const { cache, tree, nextUrl, focusAndScrollRef } = (0, _usereducer.useUnwrapState)(state);\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            changeByServerResponse,\n            tree,\n            focusAndScrollRef,\n            nextUrl\n        };\n    }, [\n        changeByServerResponse,\n        tree,\n        focusAndScrollRef,\n        nextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        }, headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            cache.rsc,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (true) {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (true) {\n            const { DevRootHTTPAccessFallbackBoundary } = __webpack_require__(/*! ./dev-root-http-access-fallback-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = (__webpack_require__(/*! ./react-dev-overlay/app/hot-reloader-client */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js\")[\"default\"]);\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            assetPrefix: assetPrefix,\n            globalError: globalError,\n            children: content\n        });\n    } else {}\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: (0, _usereducer.useUnwrapState)(state)\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                value: pathParams,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                    value: pathname,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                        value: searchParams,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                            value: globalLayoutRouterContext,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                value: appRouter,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                    value: layoutRouterContext,\n                                    children: content\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\n_s(Router, \"bU8t8nCPb2ycaFr1siwKA2Gych0=\", false, function() {\n    return [\n        useChangeByServerResponse,\n        useNavigate\n    ];\n});\n_c2 = Router;\nfunction AppRouter(param) {\n    let { actionQueue, globalErrorComponentAndStyles: [globalErrorComponent, globalErrorStyles], assetPrefix } = param;\n    (0, _navfailurehandler.useNavFailureHandler)();\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n        // At the very top level, use the default GlobalError component as the final fallback.\n        // When the app router itself fails, which means the framework itself fails, we show the default error.\n        errorComponent: _errorboundary.default,\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n            actionQueue: actionQueue,\n            assetPrefix: assetPrefix,\n            globalError: [\n                globalErrorComponent,\n                globalErrorStyles\n            ]\n        })\n    });\n}\n_c3 = AppRouter;\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    _s1();\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId =  false ? 0 : '';\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: \"\" + href + dplId,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n_s1(RuntimeStyles, \"Eht7Kgdrrgt5B4LSklQ7qDPo8Aw=\");\n_c4 = RuntimeStyles;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"HistoryUpdater\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Router\");\n$RefreshReg$(_c3, \"AppRouter\");\n$RefreshReg$(_c4, \"RuntimeStyles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQStKZ0JBLG9CQUFvQjtlQUFwQkE7O0lBOUVBQyxpQkFBaUI7ZUFBakJBOztJQWdtQmhCLE9Bd0JDO2VBeEJ1QkM7Ozs7OzZFQXZxQmpCOzJEQUtBO2dEQWFBOytDQU8yQjs2REFLM0I7d0NBQ29DO3FGQUtwQzttQ0FDZTt5Q0FDTTtnREFDTzs4Q0FDRjs2Q0FDRDtnREFDRzs0Q0FDSjt5Q0FDSDtnREFDTTsrQ0FFRzsyQ0FDSzswQ0FFVztzQ0FDYTsyQ0FDcEI7NkNBQ2Q7bUNBQ0M7QUFFakMsTUFBTUMsZ0JBRUYsQ0FBQztBQUVMLFNBQVNDLGNBQWNDLEdBQVE7SUFDN0IsT0FBT0EsSUFBSUMsTUFBTSxLQUFLQyxPQUFPQyxRQUFRLENBQUNGLE1BQU07QUFDOUM7QUFTTyxTQUFTTCxrQkFBa0JRLElBQVk7SUFDNUMsa0RBQWtEO0lBQ2xELElBQUlDLENBQUFBLEdBQUFBLE9BQUFBLEtBQUFBLEVBQU1ILE9BQU9JLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlQO0lBQ0osSUFBSTtRQUNGQSxNQUFNLElBQUlRLElBQUlDLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlMLE9BQU9GLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSTtJQUN2RCxFQUFFLE9BQU9NLEdBQUc7UUFDViwyRUFBMkU7UUFDM0Usa0RBQWtEO1FBQ2xELE1BQU0scUJBRUwsQ0FGSyxJQUFJQyxNQUNQLHNCQUFtQlAsT0FBSywrQ0FEckI7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsdUVBQXVFO0lBQ3ZFLElBQUlRLElBQW9CLEVBQW9CO1FBQzFDLE9BQU87SUFDVDtJQUVBLHFEQUFxRDtJQUNyRCxJQUFJYixjQUFjQyxNQUFNO1FBQ3RCLE9BQU87SUFDVDtJ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Y0FBY00sSUFBSTtJQUM3QzdJLENBQUFBLEdBQUFBLE9BQUFBLFNBQUFBLEVBQVU7UUFDUixNQUFNdUosVUFBVSxJQUFNSixZQUFZLENBQUNLLElBQU1BLElBQUk7UUFDN0NmLG9CQUFvQkssR0FBRyxDQUFDUztRQUN4QixJQUFJRCx1QkFBdUJmLGNBQWNNLElBQUksRUFBRTtZQUM3Q1U7UUFDRjtRQUNBLE9BQU87WUFDTGQsb0JBQW9CZ0IsTUFBTSxDQUFDRjtRQUM3QjtJQUNGLEdBQUc7UUFBQ0Q7UUFBb0JIO0tBQVk7SUFFcEMsTUFBTU8sUUFBUWpMLE1BQThCLEdBQ3ZDLENBQXFDLEdBQ3RDO0lBQ0osT0FBTztXQUFJOEo7S0FBYyxDQUFDcUIsR0FBRyxDQUFDLENBQUMzTCxNQUFNNEwsSUFBQUEsV0FBQUEsR0FDbkMscUJBQUNDLFFBQUFBO1lBRUNDLEtBQUk7WUFDSjlMLE1BQU8sS0FBRUEsT0FBT3lMO1lBQ2hCLGFBQWE7WUFDYk0sWUFBVztXQUpOSDtBQVVYOztNQTdCU3BDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1pa2lfXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcYXBwLXJvdXRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwge1xuICB1c2UsXG4gIHVzZUVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlQ2FsbGJhY2ssXG4gIHN0YXJ0VHJhbnNpdGlvbixcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0LFxuICB1c2VEZWZlcnJlZFZhbHVlLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIEFwcFJvdXRlckNvbnRleHQsXG4gIExheW91dFJvdXRlckNvbnRleHQsXG4gIEdsb2JhbExheW91dFJvdXRlckNvbnRleHQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGUsXG4gIEFwcFJvdXRlckluc3RhbmNlLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7XG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgQUNUSU9OX05BVklHQVRFLFxuICBBQ1RJT05fUFJFRkVUQ0gsXG4gIEFDVElPTl9SRUZSRVNILFxuICBBQ1RJT05fUkVTVE9SRSxcbiAgQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgUHJlZmV0Y2hLaW5kLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBBcHBSb3V0ZXJTdGF0ZSxcbiAgUmVkdWNlckFjdGlvbnMsXG4gIFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsXG4gIFJvdXRlck5hdmlnYXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dCxcbiAgUGF0aG5hbWVDb250ZXh0LFxuICBQYXRoUGFyYW1zQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZVVud3JhcFN0YXRlIH0gZnJvbSAnLi91c2UtcmVkdWNlcidcbmltcG9ydCB7XG4gIGRlZmF1bHQgYXMgRGVmYXVsdEdsb2JhbEVycm9yLFxuICBFcnJvckJvdW5kYXJ5LFxuICB0eXBlIEdsb2JhbEVycm9yQ29tcG9uZW50LFxufSBmcm9tICcuL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IHsgaXNCb3QgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBBcHBSb3V0ZXJBbm5vdW5jZXIgfSBmcm9tICcuL2FwcC1yb3V0ZXItYW5ub3VuY2VyJ1xuaW1wb3J0IHsgUmVkaXJlY3RCb3VuZGFyeSB9IGZyb20gJy4vcmVkaXJlY3QtYm91bmRhcnknXG5pbXBvcnQgeyBmaW5kSGVhZEluQ2FjaGUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZSdcbmltcG9ydCB7IHVucmVzb2x2ZWRUaGVuYWJsZSB9IGZyb20gJy4vdW5yZXNvbHZlZC10aGVuYWJsZSdcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7IGdldFNlbGVjdGVkUGFyYW1zIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IHVzZU5hdkZhaWx1cmVIYW5kbGVyIH0gZnJvbSAnLi9uYXYtZmFpbHVyZS1oYW5kbGVyJ1xuaW1wb3J0IHsgdXNlU2VydmVyQWN0aW9uRGlzcGF0Y2hlciB9IGZyb20gJy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB0eXBlIHsgQXBwUm91dGVyQWN0aW9uUXVldWUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci9hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBwcmVmZXRjaCBhcyBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5pbXBvcnQgeyBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IsIGdldFVSTEZyb21SZWRpcmVjdEVycm9yIH0gZnJvbSAnLi9yZWRpcmVjdCdcbmltcG9ydCB7IGlzUmVkaXJlY3RFcnJvciwgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcbmltcG9ydCB7IHByZWZldGNoUmVkdWNlciB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlcidcbmltcG9ydCB7IHBpbmdWaXNpYmxlTGlua3MgfSBmcm9tICcuL2xpbmtzJ1xuXG5jb25zdCBnbG9iYWxNdXRhYmxlOiB7XG4gIHBlbmRpbmdNcGFQYXRoPzogc3RyaW5nXG59ID0ge31cblxuZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmw6IFVSTCkge1xuICByZXR1cm4gdXJsLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpblxufVxuXG4vKipcbiAqIEdpdmVuIGEgbGluayBocmVmLCBjb25zdHJ1Y3RzIHRoZSBVUkwgdGhhdCBzaG91bGQgYmUgcHJlZmV0Y2hlZC4gUmV0dXJucyBudWxsXG4gKiBpbiBjYXNlcyB3aGVyZSBwcmVmZXRjaGluZyBzaG91bGQgYmUgZGlzYWJsZWQsIGxpa2UgZXh0ZXJuYWwgVVJMcywgb3JcbiAqIGR1cmluZyBkZXZlbG9wbWVudC5cbiAqIEBwYXJhbSBocmVmIFRoZSBocmVmIHBhc3NlZCB0byA8TGluaz4sIHJvdXRlci5wcmVmZXRjaCgpLCBvciBzaW1pbGFyXG4gKiBAcmV0dXJucyBBIFVSTCBvYmplY3QgdG8gcHJlZmV0Y2gsIG9yIG51bGwgaWYgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcmVmZXRjaFVSTChocmVmOiBzdHJpbmcpOiBVUkwgfCBudWxsIHtcbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZm9yIGJvdHMgYXMgdGhleSBkb24ndCBuYXZpZ2F0ZS5cbiAgaWYgKGlzQm90KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgdXJsOiBVUkxcbiAgdHJ5IHtcbiAgICB1cmwgPSBuZXcgVVJMKGFkZEJhc2VQYXRoKGhyZWYpLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHRvIHRocm93IG9yIGNhbiB3ZSBqdXN0IGNvbnNvbGUuZXJyb3IgaW5zdGVhZD8gRG9lc1xuICAgIC8vIGFueW9uZSByZWx5IG9uIHRoaXMgdGhyb3dpbmc/IChTZWVtcyB1bmxpa2VseS4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBwcmVmZXRjaCAnJHtocmVmfScgYmVjYXVzZSBpdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgVVJMLmBcbiAgICApXG4gIH1cblxuICAvLyBEb24ndCBwcmVmZXRjaCBkdXJpbmcgZGV2ZWxvcG1lbnQgKGltcHJvdmVzIGNvbXBpbGF0aW9uIHBlcmZvcm1hbmNlKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gRXh0ZXJuYWwgdXJscyBjYW4ndCBiZSBwcmVmZXRjaGVkIGluIHRoZSBzYW1lIHdheS5cbiAgaWYgKGlzRXh0ZXJuYWxVUkwodXJsKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIEhpc3RvcnlVcGRhdGVyKHtcbiAgYXBwUm91dGVyU3RhdGUsXG59OiB7XG4gIGFwcFJvdXRlclN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxufSkge1xuICB1c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgICAvLyBjbGVhciBwZW5kaW5nIFVSTCBhcyBuYXZpZ2F0aW9uIGlzIG5vIGxvbmdlclxuICAgICAgLy8gaW4gZmxpZ2h0XG4gICAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCB7IHRyZWUsIHB1c2hSZWYsIGNhbm9uaWNhbFVybCB9ID0gYXBwUm91dGVyU3RhdGVcbiAgICBjb25zdCBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICAuLi4ocHVzaFJlZi5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA/IHdpbmRvdy5oaXN0b3J5LnN0YXRlIDoge30pLFxuICAgICAgLy8gSWRlbnRpZmllciBpcyBzaG9ydGVuZWQgaW50ZW50aW9uYWxseS5cbiAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgIC8vIF9fTiBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBvbGQgcm91dGVyLlxuICAgICAgX19OQTogdHJ1ZSxcbiAgICAgIF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUU6IHRyZWUsXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHB1c2hSZWYucGVuZGluZ1B1c2ggJiZcbiAgICAgIC8vIFNraXAgcHVzaGluZyBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkgaWYgdGhlIGNhbm9uaWNhbFVybCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB1cmwuXG4gICAgICAvLyBUaGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIgYmVoYXZpb3IgZm9yIG5vcm1hbCBuYXZpZ2F0aW9uLlxuICAgICAgY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmxcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2VcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyU3RhdGVdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVGhlIE5leHQtVXJsIGFuZCB0aGUgYmFzZSB0cmVlIG1heSBhZmZlY3QgdGhlIHJlc3VsdCBvZiBhIHByZWZldGNoXG4gICAgLy8gdGFzay4gUmUtcHJlZmV0Y2ggYWxsIHZpc2libGUgbGlua3Mgd2l0aCB0aGUgdXBkYXRlZCB2YWx1ZXMuIEluIG1vc3RcbiAgICAvLyBjYXNlcywgdGhpcyB3aWxsIG5vdCByZXN1bHQgaW4gYW55IG5ldyBuZXR3b3JrIHJlcXVlc3RzLCBvbmx5IGlmXG4gICAgLy8gdGhlIHByZWZldGNoIHJlc3VsdCBhY3R1YWxseSB2YXJpZXMgb24gb25lIG9mIHRoZXNlIGlucHV0cy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgICBwaW5nVmlzaWJsZUxpbmtzKGFwcFJvdXRlclN0YXRlLm5leHRVcmwsIGFwcFJvdXRlclN0YXRlLnRyZWUpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyU3RhdGUubmV4dFVybCwgYXBwUm91dGVyU3RhdGUudHJlZV0pXG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKCk6IENhY2hlTm9kZSB7XG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjOiBudWxsLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgbG9hZGluZzogbnVsbCxcbiAgfVxufVxuXG4vKipcbiAqIFNlcnZlciByZXNwb25zZSB0aGF0IG9ubHkgcGF0Y2hlcyB0aGUgY2FjaGUgYW5kIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHVzZUNoYW5nZUJ5U2VydmVyUmVzcG9uc2UoXG4gIGRpc3BhdGNoOiBSZWFjdC5EaXNwYXRjaDxSZWR1Y2VyQWN0aW9ucz5cbik6IFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2Uge1xuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKHsgcHJldmlvdXNUcmVlLCBzZXJ2ZXJSZXNwb25zZSB9KSA9PiB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICBwcmV2aW91c1RyZWUsXG4gICAgICAgICAgc2VydmVyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sXG4gICAgW2Rpc3BhdGNoXVxuICApXG59XG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKGRpc3BhdGNoOiBSZWFjdC5EaXNwYXRjaDxSZWR1Y2VyQWN0aW9ucz4pOiBSb3V0ZXJOYXZpZ2F0ZSB7XG4gIHJldHVybiB1c2VDYWxsYmFjayhcbiAgICAoaHJlZiwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYWRkQmFzZVBhdGgoaHJlZiksIGxvY2F0aW9uLmhyZWYpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgICAgIHdpbmRvdy5uZXh0Ll9fcGVuZGluZ1VybCA9IHVybFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBBQ1RJT05fTkFWSUdBVEUsXG4gICAgICAgIHVybCxcbiAgICAgICAgaXNFeHRlcm5hbFVybDogaXNFeHRlcm5hbFVSTCh1cmwpLFxuICAgICAgICBsb2NhdGlvblNlYXJjaDogbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBzaG91bGRTY3JvbGw6IHNob3VsZFNjcm9sbCA/PyB0cnVlLFxuICAgICAgICBuYXZpZ2F0ZVR5cGUsXG4gICAgICAgIGFsbG93QWxpYXNpbmc6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG4gICAgW2Rpc3BhdGNoXVxuICApXG59XG5cbmZ1bmN0aW9uIGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhOiBhbnkpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCkgZGF0YSA9IHt9XG4gIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gIGNvbnN0IF9fTkEgPSBjdXJyZW50U3RhdGU/Ll9fTkFcbiAgaWYgKF9fTkEpIHtcbiAgICBkYXRhLl9fTkEgPSBfX05BXG4gIH1cbiAgY29uc3QgX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSA9XG4gICAgY3VycmVudFN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gIGlmIChfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFKSB7XG4gICAgZGF0YS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFID0gX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gSGVhZCh7XG4gIGhlYWRDYWNoZU5vZGUsXG59OiB7XG4gIGhlYWRDYWNoZU5vZGU6IENhY2hlTm9kZSB8IG51bGxcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICAvLyBJZiB0aGlzIHNlZ21lbnQgaGFzIGEgYHByZWZldGNoSGVhZGAsIGl0J3MgdGhlIHN0YXRpY2FsbHkgcHJlZmV0Y2hlZCBkYXRhLlxuICAvLyBXZSBzaG91bGQgdXNlIHRoYXQgb24gaW5pdGlhbCByZW5kZXIgaW5zdGVhZCBvZiBgaGVhZGAuIFRoZW4gd2UnbGwgc3dpdGNoXG4gIC8vIHRvIGBoZWFkYCB3aGVuIHRoZSBkeW5hbWljIHJlc3BvbnNlIHN0cmVhbXMgaW4uXG4gIGNvbnN0IGhlYWQgPSBoZWFkQ2FjaGVOb2RlICE9PSBudWxsID8gaGVhZENhY2hlTm9kZS5oZWFkIDogbnVsbFxuICBjb25zdCBwcmVmZXRjaEhlYWQgPVxuICAgIGhlYWRDYWNoZU5vZGUgIT09IG51bGwgPyBoZWFkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCA6IG51bGxcblxuICAvLyBJZiBubyBwcmVmZXRjaCBkYXRhIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgYGhlYWRgLlxuICBjb25zdCByZXNvbHZlZFByZWZldGNoUnNjID0gcHJlZmV0Y2hIZWFkICE9PSBudWxsID8gcHJlZmV0Y2hIZWFkIDogaGVhZFxuXG4gIC8vIFdlIHVzZSBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gaGFuZGxlIHN3aXRjaGluZyBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZFxuICAvLyBmaW5hbCB2YWx1ZXMuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgcmV0dXJuZWQgb24gaW5pdGlhbCByZW5kZXIsIHRoZW4gaXRcbiAgLy8gcmUtcmVuZGVycyB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgcmV0dXJuIHVzZURlZmVycmVkVmFsdWUoaGVhZCwgcmVzb2x2ZWRQcmVmZXRjaFJzYylcbn1cblxuLyoqXG4gKiBUaGUgZ2xvYmFsIHJvdXRlciB0aGF0IHdyYXBzIHRoZSBhcHBsaWNhdGlvbiBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBSb3V0ZXIoe1xuICBhY3Rpb25RdWV1ZSxcbiAgYXNzZXRQcmVmaXgsXG4gIGdsb2JhbEVycm9yLFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xuICBnbG9iYWxFcnJvcjogW0dsb2JhbEVycm9yQ29tcG9uZW50LCBSZWFjdC5SZWFjdE5vZGVdXG59KSB7XG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihhY3Rpb25RdWV1ZSlcbiAgY29uc3QgeyBjYW5vbmljYWxVcmwgfSA9IHVzZVVud3JhcFN0YXRlKHN0YXRlKVxuICAvLyBBZGQgbWVtb2l6ZWQgcGF0aG5hbWUvcXVlcnkgZm9yIHVzZVNlYXJjaFBhcmFtcyBhbmQgdXNlUGF0aG5hbWUuXG4gIGNvbnN0IHsgc2VhcmNoUGFyYW1zLCBwYXRobmFtZSB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoaXMgaXMgdHVybmVkIGludG8gYSByZWFkb25seSBjbGFzcyBpbiBgdXNlU2VhcmNoUGFyYW1zYFxuICAgICAgc2VhcmNoUGFyYW1zOiB1cmwuc2VhcmNoUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGhhc0Jhc2VQYXRoKHVybC5wYXRobmFtZSlcbiAgICAgICAgPyByZW1vdmVCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgIDogdXJsLnBhdGhuYW1lLFxuICAgIH1cbiAgfSwgW2Nhbm9uaWNhbFVybF0pXG5cbiAgY29uc3QgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSA9IHVzZUNoYW5nZUJ5U2VydmVyUmVzcG9uc2UoZGlzcGF0Y2gpXG4gIGNvbnN0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoZGlzcGF0Y2gpXG4gIHVzZVNlcnZlckFjdGlvbkRpc3BhdGNoZXIoZGlzcGF0Y2gpXG5cbiAgLyoqXG4gICAqIFRoZSBhcHAgcm91dGVyIHRoYXQgaXMgZXhwb3NlZCB0aHJvdWdoIGB1c2VSb3V0ZXJgLiBJdCdzIG9ubHkgY29uY2VybmVkIHdpdGggZGlzcGF0Y2hpbmcgYWN0aW9ucyB0byB0aGUgcmVkdWNlciwgZG9lcyBub3QgaG9sZCBzdGF0ZS5cbiAgICovXG4gIGNvbnN0IGFwcFJvdXRlciA9IHVzZU1lbW88QXBwUm91dGVySW5zdGFuY2U+KCgpID0+IHtcbiAgICBjb25zdCByb3V0ZXJJbnN0YW5jZTogQXBwUm91dGVySW5zdGFuY2UgPSB7XG4gICAgICBiYWNrOiAoKSA9PiB3aW5kb3cuaGlzdG9yeS5iYWNrKCksXG4gICAgICBmb3J3YXJkOiAoKSA9PiB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gICAgICBwcmVmZXRjaDogcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgICAgID8gLy8gVW5saWtlIHRoZSBvbGQgaW1wbGVtZW50YXRpb24sIHRoZSBTZWdtZW50IENhY2hlIGRvZXNuJ3Qgc3RvcmUgaXRzXG4gICAgICAgICAgLy8gZGF0YSBpbiB0aGUgcm91dGVyIHJlZHVjZXIgc3RhdGU7IGl0IHdyaXRlcyBpbnRvIGEgZ2xvYmFsIG11dGFibGVcbiAgICAgICAgICAvLyBjYWNoZS4gU28gd2UgZG9uJ3QgbmVlZCB0byBkaXNwYXRjaCBhbiBhY3Rpb24uXG4gICAgICAgICAgKGhyZWYsIG9wdGlvbnMpID0+XG4gICAgICAgICAgICBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUoXG4gICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgIGFjdGlvblF1ZXVlLnN0YXRlLm5leHRVcmwsXG4gICAgICAgICAgICAgIGFjdGlvblF1ZXVlLnN0YXRlLnRyZWUsXG4gICAgICAgICAgICAgIG9wdGlvbnM/LmtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMXG4gICAgICAgICAgICApXG4gICAgICAgIDogKGhyZWYsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgb2xkIHByZWZldGNoIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgY29uc3QgdXJsID0gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZilcbiAgICAgICAgICAgIGlmICh1cmwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHByZWZldGNoIHJlZHVjZXIgZG9lc24ndCBhY3R1YWxseSB1cGRhdGUgYW55IHN0YXRlIG9yXG4gICAgICAgICAgICAgIC8vIHRyaWdnZXIgYSByZXJlbmRlci4gSXQganVzdCB3cml0ZXMgdG8gYSBtdXRhYmxlIGNhY2hlLiBTbyB3ZVxuICAgICAgICAgICAgICAvLyBzaG91bGRuJ3QgYm90aGVyIGNhbGxpbmcgc2V0U3RhdGUvZGlzcGF0Y2g7IHdlIGNhbiBqdXN0IHJlLXJ1blxuICAgICAgICAgICAgICAvLyB0aGUgcmVkdWNlciBkaXJlY3RseSB1c2luZyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgdGhpcyBhd2F5IGZyb20gYSBcInJlZHVjZXJcIiBzbyBpdCdzXG4gICAgICAgICAgICAgIC8vIGxlc3MgY29uZnVzaW5nLlxuICAgICAgICAgICAgICBwcmVmZXRjaFJlZHVjZXIoYWN0aW9uUXVldWUuc3RhdGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBBQ1RJT05fUFJFRkVUQ0gsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGtpbmQ6IG9wdGlvbnM/LmtpbmQgPz8gUHJlZmV0Y2hLaW5kLkZVTEwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgIHJlcGxhY2U6IChocmVmLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncmVwbGFjZScsIG9wdGlvbnMuc2Nyb2xsID8/IHRydWUpXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcHVzaDogKGhyZWYsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIG5hdmlnYXRlKGhyZWYsICdwdXNoJywgb3B0aW9ucy5zY3JvbGwgPz8gdHJ1ZSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZWZyZXNoOiAoKSA9PiB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX1JFRlJFU0gsXG4gICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBobXJSZWZyZXNoOiAoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdobXJSZWZyZXNoIGNhbiBvbmx5IGJlIHVzZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gUGxlYXNlIHVzZSByZWZyZXNoIGluc3RlYWQuJ1xuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICB0eXBlOiBBQ1RJT05fSE1SX1JFRlJFU0gsXG4gICAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGVySW5zdGFuY2VcbiAgfSwgW2FjdGlvblF1ZXVlLCBkaXNwYXRjaCwgbmF2aWdhdGVdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRXhpc3RzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuIERvbid0IHVzZSBpbiBhcHBsaWNhdGlvbiBjb2RlLlxuICAgIGlmICh3aW5kb3cubmV4dCkge1xuICAgICAgd2luZG93Lm5leHQucm91dGVyID0gYXBwUm91dGVyXG4gICAgfVxuICB9LCBbYXBwUm91dGVyXSlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGNvbnN0IHsgY2FjaGUsIHByZWZldGNoQ2FjaGUsIHRyZWUgfSA9IHVzZVVud3JhcFN0YXRlKHN0YXRlKVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gQWRkIGB3aW5kb3cubmRgIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgICAvLyBUaGlzIGlzIG5vdCBtZWFudCBmb3IgdXNlIGluIGFwcGxpY2F0aW9ucyBhcyBjb25jdXJyZW50IHJlbmRlcmluZyB3aWxsIGFmZmVjdCB0aGUgY2FjaGUvdHJlZS9yb3V0ZXIuXG4gICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgZm9yIGRlYnVnZ2luZ1xuICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICByb3V0ZXI6IGFwcFJvdXRlcixcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIHRyZWUsXG4gICAgICB9XG4gICAgfSwgW2FwcFJvdXRlciwgY2FjaGUsIHByZWZldGNoQ2FjaGUsIHRyZWVdKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgYXBwIGlzIHJlc3RvcmVkIGZyb20gYmZjYWNoZSwgaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgLy8gcHVzaFJlZi5tcGFOYXZpZ2F0aW9uIGlzIHRydWUsIHdoaWNoIHdvdWxkIG1lYW4gdGhhdCBhbnkgcmUtcmVuZGVyIG9mIHRoaXMgY29tcG9uZW50XG4gICAgLy8gd291bGQgdHJpZ2dlciB0aGUgbXBhIG5hdmlnYXRpb24gbG9naWMgYWdhaW4gZnJvbSB0aGUgbGluZXMgYmVsb3cuXG4gICAgLy8gVGhpcyB3aWxsIHJlc3RvcmUgdGhlIHJvdXRlciB0byB0aGUgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgYXBwIGlzIHJlc3RvcmVkIGZyb20gYmZjYWNoZS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQYWdlU2hvdyhldmVudDogUGFnZVRyYW5zaXRpb25FdmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAhZXZlbnQucGVyc2lzdGVkIHx8XG4gICAgICAgICF3aW5kb3cuaGlzdG9yeS5zdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgcGVuZGluZ01wYVBhdGggdmFsdWUgc28gdGhhdCBhIHN1YnNlcXVlbnQgTVBBIG5hdmlnYXRpb24gdG8gdGhlIHNhbWUgVVJMIGNhbiBiZSB0cmlnZ2VyZWQuXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGlmIHRoZSBicm93c2VyIHJlc3RvcmVkIGZyb20gYmZjYWNoZSwgdGhlIHBlbmRpbmdNcGFQYXRoIHdvdWxkIHN0aWxsIGJlIHNldCB0byB0aGUgdmFsdWVcbiAgICAgIC8vIG9mIHRoZSBsYXN0IE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgICAgICB1cmw6IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLFxuICAgICAgICB0cmVlOiB3aW5kb3cuaGlzdG9yeS5zdGF0ZS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBoYW5kbGVQYWdlU2hvdylcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBoYW5kbGVQYWdlU2hvdylcbiAgICB9XG4gIH0sIFtkaXNwYXRjaF0pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBFbnN1cmUgdGhhdCBhbnkgcmVkaXJlY3QgZXJyb3JzIHRoYXQgYnViYmxlIHVwIG91dHNpZGUgb2YgdGhlIFJlZGlyZWN0Qm91bmRhcnlcbiAgICAvLyBhcmUgY2F1Z2h0IGFuZCBoYW5kbGVkIGJ5IHRoZSByb3V0ZXIuXG4gICAgZnVuY3Rpb24gaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QoXG4gICAgICBldmVudDogRXJyb3JFdmVudCB8IFByb21pc2VSZWplY3Rpb25FdmVudFxuICAgICkge1xuICAgICAgY29uc3QgZXJyb3IgPSAncmVhc29uJyBpbiBldmVudCA/IGV2ZW50LnJlYXNvbiA6IGV2ZW50LmVycm9yXG4gICAgICBpZiAoaXNSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHVybCA9IGdldFVSTEZyb21SZWRpcmVjdEVycm9yKGVycm9yKVxuICAgICAgICBjb25zdCByZWRpcmVjdFR5cGUgPSBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IoZXJyb3IpXG4gICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09IFJlZGlyZWN0VHlwZS5wdXNoKSB7XG4gICAgICAgICAgYXBwUm91dGVyLnB1c2godXJsLCB7fSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBSb3V0ZXIucmVwbGFjZSh1cmwsIHt9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICB9XG4gIH0sIFthcHBSb3V0ZXJdKVxuXG4gIC8vIFdoZW4gbXBhTmF2aWdhdGlvbiBmbGFnIGlzIHNldCBkbyBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgbmV3IHVybC5cbiAgLy8gSW5maW5pdGVseSBzdXNwZW5kIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byByZXJlbmRlciBhbnkgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIHRoZSBuZXcgVVJMIGFuZCBhbnkgZW50YW5nbGVkIHN0YXRlIHVwZGF0ZXMgc2hvdWxkbid0XG4gIC8vIGNvbW1pdCBlaXRoZXIgKGVnOiB1c2VUcmFuc2l0aW9uIGlzUGVuZGluZyBzaG91bGQgc3RheSB0cnVlIHVudGlsIHRoZSBwYWdlXG4gIC8vIHVubG9hZHMpLlxuICAvL1xuICAvLyBUaGlzIGlzIGEgc2lkZSBlZmZlY3QgaW4gcmVuZGVyLiBEb24ndCB0cnkgdGhpcyBhdCBob21lLCBraWRzLiBJdCdzXG4gIC8vIHByb2JhYmx5IHNhZmUgYmVjYXVzZSB3ZSBrbm93IHRoaXMgaXMgYSBzaW5nbGV0b24gY29tcG9uZW50IGFuZCBpdCdzIG5ldmVyXG4gIC8vIGluIDxPZmZzY3JlZW4+LiBBdCBsZWFzdCBJIGhvcGUgc28uIChJdCB3aWxsIHJ1biB0d2ljZSBpbiBkZXYgc3RyaWN0IG1vZGUsXG4gIC8vIGJ1dCB0aGF0J3MuLi4gZmluZT8pXG4gIGNvbnN0IHsgcHVzaFJlZiB9ID0gdXNlVW53cmFwU3RhdGUoc3RhdGUpXG4gIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAvLyBpZiB0aGVyZSdzIGEgcmUtcmVuZGVyLCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYW5vdGhlciByZWRpcmVjdCBpZiBvbmUgaXMgYWxyZWFkeSBpbiBmbGlnaHQgdG8gdGhlIHNhbWUgVVJMXG4gICAgaWYgKGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggIT09IGNhbm9uaWNhbFVybCkge1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb25cbiAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoKSB7XG4gICAgICAgIGxvY2F0aW9uLmFzc2lnbihjYW5vbmljYWxVcmwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGNhbm9uaWNhbFVybClcbiAgICAgIH1cblxuICAgICAgZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCA9IGNhbm9uaWNhbFVybFxuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogU2hvdWxkIHdlIGxpc3RlbiB0byBuYXZpZ2F0ZWVycm9yIGhlcmUgdG8gY2F0Y2ggZmFpbGVkXG4gICAgLy8gbmF2aWdhdGlvbnMgc29tZWhvdz8gQW5kIHNob3VsZCB3ZSBjYWxsIHdpbmRvdy5zdG9wKCkgaWYgYSBTUEEgbmF2aWdhdGlvblxuICAgIC8vIHNob3VsZCBpbnRlcnJ1cHQgYW4gTVBBIG9uZT9cbiAgICB1c2UodW5yZXNvbHZlZFRoZW5hYmxlKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFB1c2hTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZS5iaW5kKHdpbmRvdy5oaXN0b3J5KVxuICAgIGNvbnN0IG9yaWdpbmFsUmVwbGFjZVN0YXRlID0gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlLmJpbmQoXG4gICAgICB3aW5kb3cuaGlzdG9yeVxuICAgIClcblxuICAgIC8vIEVuc3VyZSB0aGUgY2Fub25pY2FsIFVSTCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIgaXMgdXBkYXRlZCB3aGVuIHRoZSBVUkwgaXMgY2hhbmdlZCBzbyB0aGF0IGB1c2VQYXRobmFtZWAgYW5kIGB1c2VTZWFyY2hQYXJhbXNgIGhvbGQgdGhlIHB1c2hlZCB2YWx1ZXMuXG4gICAgY29uc3QgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlID0gKFxuICAgICAgdXJsOiBzdHJpbmcgfCBVUkwgfCBudWxsIHwgdW5kZWZpbmVkXG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgIGNvbnN0IHRyZWU6IEZsaWdodFJvdXRlclN0YXRlIHwgdW5kZWZpbmVkID1cbiAgICAgICAgd2luZG93Lmhpc3Rvcnkuc3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcblxuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgICAgICAgIHVybDogbmV3IFVSTCh1cmwgPz8gaHJlZiwgaHJlZiksXG4gICAgICAgICAgdHJlZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2ggcHVzaFN0YXRlIHRvIGVuc3VyZSBleHRlcm5hbCBjaGFuZ2VzIHRvIHRoZSBoaXN0b3J5IGFyZSByZWZsZWN0ZWQgaW4gdGhlIE5leHQuanMgUm91dGVyLlxuICAgICAqIEVuc3VyZXMgTmV4dC5qcyBpbnRlcm5hbCBoaXN0b3J5IHN0YXRlIGlzIGNvcGllZCB0byB0aGUgbmV3IGhpc3RvcnkgZW50cnkuXG4gICAgICogRW5zdXJlcyB1c2VQYXRobmFtZSBhbmQgdXNlU2VhcmNoUGFyYW1zIGhvbGQgdGhlIG5ld2x5IHByb3ZpZGVkIHVybC5cbiAgICAgKi9cbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbiBwdXNoU3RhdGUoXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBfdW51c2VkOiBzdHJpbmcsXG4gICAgICB1cmw/OiBzdHJpbmcgfCBVUkwgfCBudWxsXG4gICAgKTogdm9pZCB7XG4gICAgICAvLyBBdm9pZCBhIGxvb3Agd2hlbiBOZXh0LmpzIGludGVybmFscyB0cmlnZ2VyIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGVcbiAgICAgIGlmIChkYXRhPy5fX05BIHx8IGRhdGE/Ll9OKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFB1c2hTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YSlcblxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UodXJsKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ2luYWxQdXNoU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoIHJlcGxhY2VTdGF0ZSB0byBlbnN1cmUgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgaGlzdG9yeSBhcmUgcmVmbGVjdGVkIGluIHRoZSBOZXh0LmpzIFJvdXRlci5cbiAgICAgKiBFbnN1cmVzIE5leHQuanMgaW50ZXJuYWwgaGlzdG9yeSBzdGF0ZSBpcyBjb3BpZWQgdG8gdGhlIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEVuc3VyZXMgdXNlUGF0aG5hbWUgYW5kIHVzZVNlYXJjaFBhcmFtcyBob2xkIHRoZSBuZXdseSBwcm92aWRlZCB1cmwuXG4gICAgICovXG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgX3VudXNlZDogc3RyaW5nLFxuICAgICAgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbFxuICAgICk6IHZvaWQge1xuICAgICAgLy8gQXZvaWQgYSBsb29wIHdoZW4gTmV4dC5qcyBpbnRlcm5hbHMgdHJpZ2dlciBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlXG4gICAgICBpZiAoZGF0YT8uX19OQSB8fCBkYXRhPy5fTikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXBsYWNlU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgICAgfVxuICAgICAgZGF0YSA9IGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhKVxuXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSh1cmwpXG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxSZXBsYWNlU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwb3BzdGF0ZSBldmVudCwgdGhpcyBpcyB1c2VkIHRvIGhhbmRsZSBiYWNrL2ZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQnkgZGVmYXVsdCBkaXNwYXRjaGVzIEFDVElPTl9SRVNUT1JFLCBob3dldmVyIGlmIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBub3QgcHVzaGVkL3JlcGxhY2VkIGJ5IGFwcC1yb3V0ZXIgaXQgd2lsbCByZWxvYWQgdGhlIHBhZ2UuXG4gICAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICAgKi9cbiAgICBjb25zdCBvblBvcFN0YXRlID0gKGV2ZW50OiBQb3BTdGF0ZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LnN0YXRlKSB7XG4gICAgICAgIC8vIFRPRE8tQVBQOiB0aGlzIGNhc2Ugb25seSBoYXBwZW5zIHdoZW4gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSB3YXMgY2FsbGVkIG91dHNpZGUgb2YgTmV4dC5qcy4gSXQgc2hvdWxkIHByb2JhYmx5IHJlbG9hZCB0aGUgcGFnZSBpbiB0aGlzIGNhc2UuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBwdXNoZWQgYnkgdGhlIGBwYWdlc2Agcm91dGVyLlxuICAgICAgaWYgKCFldmVudC5zdGF0ZS5fX05BKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETy1BUFA6IElkZWFsbHkgdGhlIGJhY2sgYnV0dG9uIHNob3VsZCBub3QgdXNlIHN0YXJ0VHJhbnNpdGlvbiBhcyBpdCBzaG91bGQgYXBwbHkgdGhlIHVwZGF0ZXMgc3luY2hyb25vdXNseVxuICAgICAgLy8gV2l0aG91dCBzdGFydFRyYW5zaXRpb24gd29ya3MgaWYgdGhlIGNhY2hlIGlzIHRoZXJlIGZvciB0aGlzIHBhdGhcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgICB1cmw6IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLFxuICAgICAgICAgIHRyZWU6IGV2ZW50LnN0YXRlLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIHBvcHN0YXRlIGV2ZW50IHRvIGNhbGwgb25Qb3BzdGF0ZS5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPSBvcmlnaW5hbFB1c2hTdGF0ZVxuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gb3JpZ2luYWxSZXBsYWNlU3RhdGVcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpXG4gICAgfVxuICB9LCBbZGlzcGF0Y2hdKVxuXG4gIGNvbnN0IHsgY2FjaGUsIHRyZWUsIG5leHRVcmwsIGZvY3VzQW5kU2Nyb2xsUmVmIH0gPSB1c2VVbndyYXBTdGF0ZShzdGF0ZSlcblxuICBjb25zdCBtYXRjaGluZ0hlYWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gZmluZEhlYWRJbkNhY2hlKGNhY2hlLCB0cmVlWzFdKVxuICB9LCBbY2FjaGUsIHRyZWVdKVxuXG4gIC8vIEFkZCBtZW1vaXplZCBwYXRoUGFyYW1zIGZvciB1c2VQYXJhbXMuXG4gIGNvbnN0IHBhdGhQYXJhbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gZ2V0U2VsZWN0ZWRQYXJhbXModHJlZSlcbiAgfSwgW3RyZWVdKVxuXG4gIGNvbnN0IGxheW91dFJvdXRlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50VHJlZTogdHJlZSxcbiAgICAgIHBhcmVudENhY2hlTm9kZTogY2FjaGUsXG4gICAgICBwYXJlbnRTZWdtZW50UGF0aDogbnVsbCxcbiAgICAgIC8vIFJvb3Qgbm9kZSBhbHdheXMgaGFzIGB1cmxgXG4gICAgICAvLyBQcm92aWRlZCBpbiBBcHBUcmVlQ29udGV4dCB0byBlbnN1cmUgaXQgY2FuIGJlIG92ZXJ3cml0dGVuIGluIGxheW91dC1yb3V0ZXJcbiAgICAgIHVybDogY2Fub25pY2FsVXJsLFxuICAgIH1cbiAgfSwgW3RyZWUsIGNhY2hlLCBjYW5vbmljYWxVcmxdKVxuXG4gIGNvbnN0IGdsb2JhbExheW91dFJvdXRlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSxcbiAgICAgIHRyZWUsXG4gICAgICBmb2N1c0FuZFNjcm9sbFJlZixcbiAgICAgIG5leHRVcmwsXG4gICAgfVxuICB9LCBbY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSwgdHJlZSwgZm9jdXNBbmRTY3JvbGxSZWYsIG5leHRVcmxdKVxuXG4gIGxldCBoZWFkXG4gIGlmIChtYXRjaGluZ0hlYWQgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgaGVhZCBpcyB3cmFwcGVkIGluIGFuIGV4dHJhIGNvbXBvbmVudCBzbyB3ZSBjYW4gdXNlXG4gICAgLy8gYHVzZURlZmVycmVkVmFsdWVgIHRvIHN3YXAgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmQgZmluYWwgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgaGVhZC4gKFRoaXMgaXMgd2hhdCBMYXlvdXRSb3V0ZXIgZG9lcyBmb3Igc2VnbWVudCBkYXRhLCB0b28uKVxuICAgIC8vXG4gICAgLy8gVGhlIGBrZXlgIGlzIHVzZWQgdG8gcmVtb3VudCB0aGUgY29tcG9uZW50IHdoZW5ldmVyIHRoZSBoZWFkIG1vdmVzIHRvXG4gICAgLy8gYSBkaWZmZXJlbnQgc2VnbWVudC5cbiAgICBjb25zdCBbaGVhZENhY2hlTm9kZSwgaGVhZEtleV0gPSBtYXRjaGluZ0hlYWRcbiAgICBoZWFkID0gPEhlYWQga2V5PXtoZWFkS2V5fSBoZWFkQ2FjaGVOb2RlPXtoZWFkQ2FjaGVOb2RlfSAvPlxuICB9IGVsc2Uge1xuICAgIGhlYWQgPSBudWxsXG4gIH1cblxuICBsZXQgY29udGVudCA9IChcbiAgICA8UmVkaXJlY3RCb3VuZGFyeT5cbiAgICAgIHtoZWFkfVxuICAgICAge2NhY2hlLnJzY31cbiAgICAgIDxBcHBSb3V0ZXJBbm5vdW5jZXIgdHJlZT17dHJlZX0gLz5cbiAgICA8L1JlZGlyZWN0Qm91bmRhcnk+XG4gIClcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBhcHBseSBmZXcgZXJyb3IgYm91bmRhcmllcyBhbmQgaG90LXJlbG9hZGVyOlxuICAgIC8vIC0gRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5OiBhdm9pZCB1c2luZyBuYXZpZ2F0aW9uIEFQSSBsaWtlIG5vdEZvdW5kKCkgaW4gcm9vdCBsYXlvdXRcbiAgICAvLyAtIEhvdFJlbG9hZGVyOlxuICAgIC8vICAtIGhvdC1yZWxvYWQgdGhlIGFwcCB3aGVuIHRoZSBjb2RlIGNoYW5nZXNcbiAgICAvLyAgLSByZW5kZXIgZGV2IG92ZXJsYXlcbiAgICAvLyAgLSBjYXRjaCBydW50aW1lIGVycm9ycyBhbmQgZGlzcGxheSBnbG9iYWwtZXJyb3Igd2hlbiBuZWNlc3NhcnlcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHsgRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IH0gPVxuICAgICAgICByZXF1aXJlKCcuL2Rldi1yb290LWh0dHAtYWNjZXNzLWZhbGxiYWNrLWJvdW5kYXJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi9kZXYtcm9vdC1odHRwLWFjY2Vzcy1mYWxsYmFjay1ib3VuZGFyeScpXG4gICAgICBjb250ZW50ID0gKFxuICAgICAgICA8RGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5PlxuICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICA8L0RldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgIClcbiAgICB9XG4gICAgY29uc3QgSG90UmVsb2FkZXI6IHR5cGVvZiBpbXBvcnQoJy4vcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2hvdC1yZWxvYWRlci1jbGllbnQnKS5kZWZhdWx0ID1cbiAgICAgIHJlcXVpcmUoJy4vcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2hvdC1yZWxvYWRlci1jbGllbnQnKS5kZWZhdWx0XG5cbiAgICBjb250ZW50ID0gKFxuICAgICAgPEhvdFJlbG9hZGVyIGFzc2V0UHJlZml4PXthc3NldFByZWZpeH0gZ2xvYmFsRXJyb3I9e2dsb2JhbEVycm9yfT5cbiAgICAgICAge2NvbnRlbnR9XG4gICAgICA8L0hvdFJlbG9hZGVyPlxuICAgIClcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB3ZSBvbmx5IGFwcGx5IHRoZSB1c2VyLWN1c3RvbWl6ZWQgZ2xvYmFsIGVycm9yIGJvdW5kYXJ5LlxuICAgIGNvbnRlbnQgPSAoXG4gICAgICA8RXJyb3JCb3VuZGFyeVxuICAgICAgICBlcnJvckNvbXBvbmVudD17Z2xvYmFsRXJyb3JbMF19XG4gICAgICAgIGVycm9yU3R5bGVzPXtnbG9iYWxFcnJvclsxXX1cbiAgICAgID5cbiAgICAgICAge2NvbnRlbnR9XG4gICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEhpc3RvcnlVcGRhdGVyIGFwcFJvdXRlclN0YXRlPXt1c2VVbndyYXBTdGF0ZShzdGF0ZSl9IC8+XG4gICAgICA8UnVudGltZVN0eWxlcyAvPlxuICAgICAgPFBhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwYXRoUGFyYW1zfT5cbiAgICAgICAgPFBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cGF0aG5hbWV9PlxuICAgICAgICAgIDxTZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtzZWFyY2hQYXJhbXN9PlxuICAgICAgICAgICAgPEdsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICAgICAgdmFsdWU9e2dsb2JhbExheW91dFJvdXRlckNvbnRleHR9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxBcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthcHBSb3V0ZXJ9PlxuICAgICAgICAgICAgICAgIDxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtsYXlvdXRSb3V0ZXJDb250ZXh0fT5cbiAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgIDwvTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgPC9BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgPC9HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9QYXRobmFtZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L1BhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvPlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcFJvdXRlcih7XG4gIGFjdGlvblF1ZXVlLFxuICBnbG9iYWxFcnJvckNvbXBvbmVudEFuZFN0eWxlczogW2dsb2JhbEVycm9yQ29tcG9uZW50LCBnbG9iYWxFcnJvclN0eWxlc10sXG4gIGFzc2V0UHJlZml4LFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgZ2xvYmFsRXJyb3JDb21wb25lbnRBbmRTdHlsZXM6IFtHbG9iYWxFcnJvckNvbXBvbmVudCwgUmVhY3QuUmVhY3ROb2RlXVxuICBhc3NldFByZWZpeDogc3RyaW5nXG59KSB7XG4gIHVzZU5hdkZhaWx1cmVIYW5kbGVyKClcblxuICByZXR1cm4gKFxuICAgIDxFcnJvckJvdW5kYXJ5XG4gICAgICAvLyBBdCB0aGUgdmVyeSB0b3AgbGV2ZWwsIHVzZSB0aGUgZGVmYXVsdCBHbG9iYWxFcnJvciBjb21wb25lbnQgYXMgdGhlIGZpbmFsIGZhbGxiYWNrLlxuICAgICAgLy8gV2hlbiB0aGUgYXBwIHJvdXRlciBpdHNlbGYgZmFpbHMsIHdoaWNoIG1lYW5zIHRoZSBmcmFtZXdvcmsgaXRzZWxmIGZhaWxzLCB3ZSBzaG93IHRoZSBkZWZhdWx0IGVycm9yLlxuICAgICAgZXJyb3JDb21wb25lbnQ9e0RlZmF1bHRHbG9iYWxFcnJvcn1cbiAgICA+XG4gICAgICA8Um91dGVyXG4gICAgICAgIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX1cbiAgICAgICAgYXNzZXRQcmVmaXg9e2Fzc2V0UHJlZml4fVxuICAgICAgICBnbG9iYWxFcnJvcj17W2dsb2JhbEVycm9yQ29tcG9uZW50LCBnbG9iYWxFcnJvclN0eWxlc119XG4gICAgICAvPlxuICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgKVxufVxuXG5jb25zdCBydW50aW1lU3R5bGVzID0gbmV3IFNldDxzdHJpbmc+KClcbmxldCBydW50aW1lU3R5bGVDaGFuZ2VkID0gbmV3IFNldDwoKSA9PiB2b2lkPigpXG5cbmdsb2JhbFRoaXMuX05fRV9TVFlMRV9MT0FEID0gZnVuY3Rpb24gKGhyZWY6IHN0cmluZykge1xuICBsZXQgbGVuID0gcnVudGltZVN0eWxlcy5zaXplXG4gIHJ1bnRpbWVTdHlsZXMuYWRkKGhyZWYpXG4gIGlmIChydW50aW1lU3R5bGVzLnNpemUgIT09IGxlbikge1xuICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIH1cbiAgLy8gVE9ETyBmaWd1cmUgb3V0IGhvdyB0byBnZXQgYSBwcm9taXNlIGhlcmVcbiAgLy8gQnV0IG1heWJlIGl0J3Mgbm90IG5lY2Vzc2FyeSBhcyByZWFjdCB3b3VsZCBibG9jayByZW5kZXJpbmcgdW50aWwgaXQncyBsb2FkZWRcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG59XG5cbmZ1bmN0aW9uIFJ1bnRpbWVTdHlsZXMoKSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IFJlYWN0LnVzZVN0YXRlKDApXG4gIGNvbnN0IHJlbmRlcmVkU3R5bGVzU2l6ZSA9IHJ1bnRpbWVTdHlsZXMuc2l6ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNoYW5nZWQgPSAoKSA9PiBmb3JjZVVwZGF0ZSgoYykgPT4gYyArIDEpXG4gICAgcnVudGltZVN0eWxlQ2hhbmdlZC5hZGQoY2hhbmdlZClcbiAgICBpZiAocmVuZGVyZWRTdHlsZXNTaXplICE9PSBydW50aW1lU3R5bGVzLnNpemUpIHtcbiAgICAgIGNoYW5nZWQoKVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcnVudGltZVN0eWxlQ2hhbmdlZC5kZWxldGUoY2hhbmdlZClcbiAgICB9XG4gIH0sIFtyZW5kZXJlZFN0eWxlc1NpemUsIGZvcmNlVXBkYXRlXSlcblxuICBjb25zdCBkcGxJZCA9IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgID8gYD9kcGw9JHtwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUR9YFxuICAgIDogJydcbiAgcmV0dXJuIFsuLi5ydW50aW1lU3R5bGVzXS5tYXAoKGhyZWYsIGkpID0+IChcbiAgICA8bGlua1xuICAgICAga2V5PXtpfVxuICAgICAgcmVsPVwic3R5bGVzaGVldFwiXG4gICAgICBocmVmPXtgJHtocmVmfSR7ZHBsSWR9YH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHByZWNlZGVuY2U9XCJuZXh0XCJcbiAgICAgIC8vIFRPRE8gZmlndXJlIG91dCBjcm9zc09yaWdpbiBhbmQgbm9uY2VcbiAgICAgIC8vIGNyb3NzT3JpZ2luPXtUT0RPfVxuICAgICAgLy8gbm9uY2U9e1RPRE99XG4gICAgLz5cbiAgKSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImNyZWF0ZVByZWZldGNoVVJMIiwiQXBwUm91dGVyIiwiZ2xvYmFsTXV0YWJsZSIsImlzRXh0ZXJuYWxVUkwiLCJ1cmwiLCJvcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlVSTCIsImFkZEJhc2VQYXRoIiwiXyIsIkVycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiSGlzdG9yeVVwZGF0ZXIiLCJhcHBSb3V0ZXJTdGF0ZSIsInVzZUluc2VydGlvbkVmZmVjdCIsIl9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkciLCJuZXh0IiwiX19wZW5kaW5nVXJsIiwidW5kZWZpbmVkIiwidHJlZSIsInB1c2hSZWYiLCJjYW5vbmljYWxVcmwiLCJoaXN0b3J5U3RhdGUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImhpc3RvcnkiLCJzdGF0ZSIsIl9fTkEiLCJfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFIiwicGVuZGluZ1B1c2giLCJjcmVhdGVIcmVmRnJvbVVybCIsInB1c2hTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsInVzZUVmZmVjdCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInBpbmdWaXNpYmxlTGlua3MiLCJuZXh0VXJsIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJwYXJhbGxlbFJvdXRlcyIsIk1hcCIsImxvYWRpbmciLCJ1c2VDaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwiZGlzcGF0Y2giLCJ1c2VDYWxsYmFjayIsInByZXZpb3VzVHJlZSIsInNlcnZlclJlc3BvbnNlIiwic3RhcnRUcmFuc2l0aW9uIiwidHlwZSIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJ1c2VOYXZpZ2F0ZSIsIm5hdmlnYXRlVHlwZSIsInNob3VsZFNjcm9sbCIsIkFDVElPTl9OQVZJR0FURSIsImlzRXh0ZXJuYWxVcmwiLCJsb2NhdGlvblNlYXJjaCIsInNlYXJjaCIsImFsbG93QWxpYXNpbmciLCJjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUiLCJkYXRhIiwiY3VycmVudFN0YXRlIiwiSGVhZCIsImhlYWRDYWNoZU5vZGUiLCJyZXNvbHZlZFByZWZldGNoUnNjIiwidXNlRGVmZXJyZWRWYWx1ZSIsIlJvdXRlciIsImFjdGlvblF1ZXVlIiwiYXNzZXRQcmVmaXgiLCJnbG9iYWxFcnJvciIsInVzZVJlZHVjZXIiLCJ1c2VVbndyYXBTdGF0ZSIsInNlYXJjaFBhcmFtcyIsInBhdGhuYW1lIiwidXNlTWVtbyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJjaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwibmF2aWdhdGUiLCJ1c2VTZXJ2ZXJBY3Rpb25EaXNwYXRjaGVyIiwiYXBwUm91dGVyIiwicm91dGVySW5zdGFuY2UiLCJiYWNrIiwiZm9yd2FyZCIsInByZWZldGNoIiwib3B0aW9ucyIsInByZWZldGNoV2l0aFNlZ21lbnRDYWNoZSIsImtpbmQiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwicHJlZmV0Y2hSZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwicmVwbGFjZSIsInNjcm9sbCIsInB1c2giLCJyZWZyZXNoIiwiQUNUSU9OX1JFRlJFU0giLCJobXJSZWZyZXNoIiwiQUNUSU9OX0hNUl9SRUZSRVNIIiwicm91dGVyIiwiY2FjaGUiLCJwcmVmZXRjaENhY2hlIiwibmQiLCJoYW5kbGVQYWdlU2hvdyIsImV2ZW50IiwicGVyc2lzdGVkIiwicGVuZGluZ01wYVBhdGgiLCJBQ1RJT05fUkVTVE9SRSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QiLCJlcnJvciIsInJlYXNvbiIsImlzUmVkaXJlY3RFcnJvciIsInByZXZlbnREZWZhdWx0IiwiZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IiLCJyZWRpcmVjdFR5cGUiLCJnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IiLCJSZWRpcmVjdFR5cGUiLCJtcGFOYXZpZ2F0aW9uIiwiYXNzaWduIiwidXNlIiwidW5yZXNvbHZlZFRoZW5hYmxlIiwib3JpZ2luYWxQdXNoU3RhdGUiLCJiaW5kIiwib3JpZ2luYWxSZXBsYWNlU3RhdGUiLCJhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UiLCJfdW51c2VkIiwiX04iLCJvblBvcFN0YXRlIiwicmVsb2FkIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJtYXRjaGluZ0hlYWQiLCJmaW5kSGVhZEluQ2FjaGUiLCJwYXRoUGFyYW1zIiwiZ2V0U2VsZWN0ZWRQYXJhbXMiLCJsYXlvdXRSb3V0ZXJDb250ZXh0IiwicGFyZW50VHJlZSIsInBhcmVudENhY2hlTm9kZSIsInBhcmVudFNlZ21lbnRQYXRoIiwiZ2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsImhlYWRLZXkiLCJjb250ZW50IiwiUmVkaXJlY3RCb3VuZGFyeSIsIkFwcFJvdXRlckFubm91bmNlciIsIkRldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsInJlcXVpcmUiLCJIb3RSZWxvYWRlciIsImRlZmF1bHQiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJlcnJvclN0eWxlcyIsIlJ1bnRpbWVTdHlsZXMiLCJQYXRoUGFyYW1zQ29udGV4dCIsIlByb3ZpZGVyIiwidmFsdWUiLCJQYXRobmFtZUNvbnRleHQiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiZ2xvYmFsRXJyb3JDb21wb25lbnRBbmRTdHlsZXMiLCJnbG9iYWxFcnJvckNvbXBvbmVudCIsImdsb2JhbEVycm9yU3R5bGVzIiwidXNlTmF2RmFpbHVyZUhhbmRsZXIiLCJEZWZhdWx0R2xvYmFsRXJyb3IiLCJydW50aW1lU3R5bGVzIiwiU2V0IiwicnVudGltZVN0eWxlQ2hhbmdlZCIsImdsb2JhbFRoaXMiLCJfTl9FX1NUWUxFX0xPQUQiLCJsZW4iLCJzaXplIiwiYWRkIiwiZm9yRWFjaCIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmb3JjZVVwZGF0ZSIsIlJlYWN0IiwidXNlU3RhdGUiLCJyZW5kZXJlZFN0eWxlc1NpemUiLCJjaGFuZ2VkIiwiYyIsImRlbGV0ZSIsImRwbElkIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwibWFwIiwiaSIsImxpbmsiLCJyZWwiLCJwcmVjZWRlbmNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/globals/intercept-console-error.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    originConsoleError: function() {\n        return originConsoleError;\n    },\n    patchConsoleError: function() {\n        return patchConsoleError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../../lib/is-error */ \"(app-pages-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst _isnextroutererror = __webpack_require__(/*! ../is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../errors/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/use-error-handler.js\");\nconst _console = __webpack_require__(/*! ../../lib/console */ \"(app-pages-browser)/./node_modules/next/dist/client/lib/console.js\");\nconst originConsoleError = globalThis.console.error;\nfunction patchConsoleError() {\n    // Ensure it's only patched once\n    if (false) {}\n    window.console.error = function error() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        let maybeError;\n        if (true) {\n            const { error: replayedError } = (0, _console.parseConsoleArgs)(args);\n            if (replayedError) {\n                maybeError = replayedError;\n            } else if ((0, _iserror.default)(args[0])) {\n                maybeError = args[0];\n            } else {\n                // See https://github.com/facebook/react/blob/d50323eb845c5fde0d720cae888bf35dedd05506/packages/react-reconciler/src/ReactFiberErrorLogger.js#L78\n                maybeError = args[1];\n            }\n        } else {}\n        if (!(0, _isnextroutererror.isNextRouterError)(maybeError)) {\n            if (true) {\n                (0, _useerrorhandler.handleClientError)(// but if we pass the error directly, `handleClientError` will ignore it\n                maybeError, args, true);\n            }\n            originConsoleError.apply(window.console, args);\n        }\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=intercept-console-error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZ2xvYmFscy9pbnRlcmNlcHQtY29uc29sZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFLYUEsa0JBQWtCO2VBQWxCQTs7SUFHR0MsaUJBQWlCO2VBQWpCQTs7Ozs4RUFSSTsrQ0FDYzs2Q0FDQTtxQ0FDRDtBQUUxQixNQUFNRCxxQkFBcUJFLFdBQVdDLE9BQU8sQ0FBQ0MsS0FBSztBQUduRCxTQUFTSDtJQUNkLGdDQUFnQztJQUNoQyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFDREksT0FBT0YsT0FBTyxDQUFDQyxLQUFLLEdBQUcsU0FBU0E7UUFBTSxpQ0FBR0UsT0FBSDtZQUFHQSxJQUFBQSxDQUFILHVCQUFjOztRQUNsRCxJQUFJQztRQUNKLElBQUlDLElBQW9CLEVBQW1CO1lBQ3pDLE1BQU0sRUFBRUosT0FBT08sYUFBYSxFQUFFLEdBQUdDLENBQUFBLEdBQUFBLFNBQUFBLGdCQUFBQSxFQUFpQk47WUFDbEQsSUFBSUssZUFBZTtnQkFDakJKLGFBQWFJO1lBQ2YsT0FBTyxJQUFJRSxDQUFBQSxHQUFBQSxTQUFBQSxPQUFBQSxFQUFRUCxJQUFJLENBQUMsRUFBRSxHQUFHO2dCQUMzQkMsYUFBYUQsSUFBSSxDQUFDLEVBQUU7WUFDdEIsT0FBTztnQkFDTCxpSkFBaUo7Z0JBQ2pKQyxhQUFhRCxJQUFJLENBQUMsRUFBRTtZQUN0QjtRQUNGLE9BQU8sRUFFTjtRQUVELElBQUksQ0FBQ1EsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDUCxhQUFhO1lBQ2xDLElBQUlDLElBQW9CLEVBQW1CO2dCQUN6Q08sQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNFLHdFQUN3RTtnQkFDeEVSLFlBQ0FELE1BQ0E7WUFFSjtZQUVBTixtQkFBbUJnQixLQUFLLENBQUNYLE9BQU9GLE9BQU8sRUFBRUc7UUFDM0M7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxnbG9iYWxzXFxpbnRlcmNlcHQtY29uc29sZS1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNFcnJvciBmcm9tICcuLi8uLi8uLi9saWIvaXMtZXJyb3InXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgaGFuZGxlQ2xpZW50RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvdXNlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBwYXJzZUNvbnNvbGVBcmdzIH0gZnJvbSAnLi4vLi4vbGliL2NvbnNvbGUnXG5cbmV4cG9ydCBjb25zdCBvcmlnaW5Db25zb2xlRXJyb3IgPSBnbG9iYWxUaGlzLmNvbnNvbGUuZXJyb3JcblxuLy8gUGF0Y2ggY29uc29sZS5lcnJvciB0byBjb2xsZWN0IGluZm9ybWF0aW9uIGFib3V0IGh5ZHJhdGlvbiBlcnJvcnNcbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENvbnNvbGVFcnJvcigpIHtcbiAgLy8gRW5zdXJlIGl0J3Mgb25seSBwYXRjaGVkIG9uY2VcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgd2luZG93LmNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvciguLi5hcmdzOiBhbnlbXSkge1xuICAgIGxldCBtYXliZUVycm9yOiB1bmtub3duXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHJlcGxheWVkRXJyb3IgfSA9IHBhcnNlQ29uc29sZUFyZ3MoYXJncylcbiAgICAgIGlmIChyZXBsYXllZEVycm9yKSB7XG4gICAgICAgIG1heWJlRXJyb3IgPSByZXBsYXllZEVycm9yXG4gICAgICB9IGVsc2UgaWYgKGlzRXJyb3IoYXJnc1swXSkpIHtcbiAgICAgICAgbWF5YmVFcnJvciA9IGFyZ3NbMF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9kNTAzMjNlYjg0NWM1ZmRlMGQ3MjBjYWU4ODhiZjM1ZGVkZDA1NTA2L3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJFcnJvckxvZ2dlci5qcyNMNzhcbiAgICAgICAgbWF5YmVFcnJvciA9IGFyZ3NbMV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF5YmVFcnJvciA9IGFyZ3NbMF1cbiAgICB9XG5cbiAgICBpZiAoIWlzTmV4dFJvdXRlckVycm9yKG1heWJlRXJyb3IpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBoYW5kbGVDbGllbnRFcnJvcihcbiAgICAgICAgICAvLyByZXBsYXllZCBlcnJvcnMgaGF2ZSB0aGVpciBvd24gY29tcGxleCBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQsXG4gICAgICAgICAgLy8gYnV0IGlmIHdlIHBhc3MgdGhlIGVycm9yIGRpcmVjdGx5LCBgaGFuZGxlQ2xpZW50RXJyb3JgIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgbWF5YmVFcnJvcixcbiAgICAgICAgICBhcmdzLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBvcmlnaW5Db25zb2xlRXJyb3IuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsib3JpZ2luQ29uc29sZUVycm9yIiwicGF0Y2hDb25zb2xlRXJyb3IiLCJnbG9iYWxUaGlzIiwiY29uc29sZSIsImVycm9yIiwid2luZG93IiwiYXJncyIsIm1heWJlRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJyZXBsYXllZEVycm9yIiwicGFyc2VDb25zb2xlQXJncyIsImlzRXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImhhbmRsZUNsaWVudEVycm9yIiwiYXBwbHkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _navigationuntracked = __webpack_require__(/*! ../navigation-untracked */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation-untracked.js\");\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\nconst _warnonce = __webpack_require__(/*! ../../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    componentDidCatch() {\n        if ( true && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>\"@\" + slot).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n}\nfunction HTTPAccessFallbackBoundary(param) {\n    let { notFound, forbidden, unauthorized, children } = param;\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = HTTPAccessFallbackBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"HTTPAccessFallbackBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs4REF1SmdCQTs7O2VBQUFBOzs7Ozs2RUExSWtCO2lEQUNHO2dEQU05QjtzQ0FDa0I7MkRBQ1U7QUFxQm5DLE1BQU1DLHdDQUF3Q0MsT0FBQUEsT0FBSyxDQUFDQyxTQUFTO0lBWTNEQyxvQkFBMEI7UUFDeEIsSUFDRUMsS0FBb0IsSUFDcEIsSUFBSSxDQUFDRyxLQUFLLENBQUNDLFlBQVksSUFDdkIsSUFBSSxDQUFDRCxLQUFLLENBQUNDLFlBQVksQ0FBQ0MsSUFBSSxHQUFHLEtBQy9CLDRFQUE0RTtRQUM1RSxDQUFDLElBQUksQ0FBQ0YsS0FBSyxDQUFDQyxZQUFZLENBQUNFLEdBQUcsQ0FBQyxhQUM3QjtZQUNBLElBQUlDLGlCQUNGLDRIQUNBO1lBRUYsTUFBTUMsaUJBQWlCQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDUCxLQUFLLENBQUNDLFlBQVksRUFDdERPLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFRSxhQUFhLENBQUNELElBQy9CRSxHQUFHLENBQUMsQ0FBQ0MsT0FBVSxNQUFHQSxNQUNsQkMsSUFBSSxDQUFDO1lBRVJWLGtCQUFrQixvQkFBb0JDO1lBRXRDVSxDQUFBQSxHQUFBQSxVQUFBQSxRQUFBQSxFQUFTWDtRQUNYO0lBQ0Y7SUFFQSxPQUFPWSx5QkFBeUJDLEtBQVUsRUFBRTtRQUMxQyxJQUFJQyxDQUFBQSxHQUFBQSxvQkFBQUEseUJBQXlCLEVBQUNELFFBQVE7WUFDcEMsTUFBTUUsYUFBYUMsQ0FBQUEsR0FBQUEsb0JBQUFBLDJCQUFBQSxFQUE0Qkg7WUFDL0MsT0FBTztnQkFDTEksaUJBQWlCRjtZQUNuQjtRQUNGO1FBQ0EsbUNBQW1DO1FBQ25DLE1BQU1GO0lBQ1I7SUFFQSxPQUFPSyx5QkFDTHRCLEtBQTJDLEVBQzNDdUIsS0FBOEIsRUFDRTtRQUNoQzs7Ozs7S0FLQyxHQUNELElBQUl2QixNQUFNd0IsUUFBUSxLQUFLRCxNQUFNRSxnQkFBZ0IsSUFBSUYsTUFBTUYsZUFBZSxFQUFFO1lBQ3RFLE9BQU87Z0JBQ0xBLGlCQUFpQks7Z0JBQ2pCRCxrQkFBa0J6QixNQUFNd0IsUUFBUTtZQUNsQztRQUNGO1FBQ0EsT0FBTztZQUNMSCxpQkFBaUJFLE1BQU1GLGVBQWU7WUFDdENJLGtCQUFrQnpCLE1BQU13QixRQUFRO1FBQ2xDO0lBQ0Y7SUFFQUcsU0FBUztRQUNQLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDL0IsS0FBSztRQUNsRSxNQUFNLEVBQUVxQixlQUFlLEVBQUUsR0FBRyxJQUFJLENBQUNFLEtBQUs7UUFDdEMsTUFBTVMsa0JBQWtCO1lBQ3RCLENBQUNDLG9CQUFBQSxxQkFBcUIsQ0FBQ0MsU0FBUyxDQUFDLEVBQUVOO1lBQ25DLENBQUNLLG9CQUFBQSxxQkFBcUIsQ0FBQ0UsU0FBUyxDQUFDLEVBQUVOO1lBQ25DLENBQUNJLG9CQUFBQSxxQkFBcUIsQ0FBQ0csWUFBWSxDQUFDLEVBQUVOO1FBQ3hDO1FBRUEsSUFBSVQsaUJBQWlCO1lBQ25CLE1BQU1nQixhQUNKaEIsb0JBQW9CWSxvQkFBQUEscUJBQXFCLENBQUNDLFNBQVMsSUFBSU47WUFDekQsTUFBTVUsY0FDSmpCLG9CQUFvQlksb0JBQUFBLHFCQUFxQixDQUFDRSxTQUFTLElBQUlOO1lBQ3pELE1BQU1VLGlCQUNKbEIsb0JBQW9CWSxvQkFBQUEscUJBQXFCLENBQUNHLFlBQVksSUFBSU47WUFFNUQsa0dBQWtHO1lBQ2xHLElBQUksQ0FBRU8sQ0FBQUEsY0FBY0MsZUFBZUMsY0FBQUEsQ0FBYSxFQUFJO2dCQUNsRCxPQUFPUjtZQUNUO1lBRUEscUJBQ0U7O2tDQUNFLHFCQUFDUyxRQUFBQTt3QkFBS0MsTUFBSzt3QkFBU0MsU0FBUTs7eUJBQ1csSUFBYixjQUN4QixxQkFBQ0YsUUFBQUE7d0JBQ0NDLE1BQUs7d0JBQ0xDLFNBQVNDLENBQUFBLEdBQUFBLG9CQUFBQSxrQ0FBQUEsRUFBbUN0Qjs7b0JBRy9DVyxlQUFlLENBQUNYLGdCQUFnQjs7O1FBR3ZDO1FBRUEsT0FBT1U7SUFDVDtJQXJHQWEsWUFBWTVDLEtBQTJDLENBQUU7UUFDdkQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ3VCLEtBQUssR0FBRztZQUNYRixpQkFBaUJLO1lBQ2pCRCxrQkFBa0J6QixNQUFNd0IsUUFBUTtRQUNsQztJQUNGO0FBZ0dGO0FBRU8sb0NBQW9DLEtBS1Q7SUFMUyxNQUN6Q0ksUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFlBQVksRUFDWkMsUUFBUSxFQUN3QixHQUxTO0lBTXpDLDZFQUE2RTtJQUM3RSxxRUFBcUU7SUFDckUsd0VBQXdFO0lBQ3hFLG1FQUFtRTtJQUNuRSxNQUFNUCxXQUFXcUIsQ0FBQUEsR0FBQUEscUJBQUFBLG9CQUFBQTtJQUNqQixNQUFNNUMsZUFBZTZDLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdDLCtCQUFBQSxrQkFBa0I7SUFDbEQsTUFBTUMsbUJBQW1CLENBQUMsQ0FBRXBCLENBQUFBLFlBQVlDLGFBQWFDLFlBQUFBLENBQVc7SUFFaEUsSUFBSWtCLGtCQUFrQjtRQUNwQixxQkFDRSxxQkFBQ3ZELGlDQUFBQTtZQUNDK0IsVUFBVUE7WUFDVkksVUFBVUE7WUFDVkMsV0FBV0E7WUFDWEMsY0FBY0E7WUFDZDdCLGNBQWNBO3NCQUViOEI7O0lBR1A7SUFFQSxxQkFBTztrQkFBR0E7O0FBQ1o7S0E3QmdCdkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXGh0dHAtYWNjZXNzLWZhbGxiYWNrXFxlcnJvci1ib3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8qKlxuICogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkgaXMgYSBib3VuZGFyeSB0aGF0IGNhdGNoZXMgZXJyb3JzIGFuZCByZW5kZXJzIGFcbiAqIGZhbGxiYWNrIGNvbXBvbmVudCBmb3IgSFRUUCBlcnJvcnMuXG4gKlxuICogSXQgcmVjZWl2ZXMgdGhlIHN0YXR1cyBjb2RlLCBhbmQgZGV0ZXJtaW5lIGlmIGl0IHNob3VsZCByZW5kZXIgZmFsbGJhY2tzIGZvciBmZXcgSFRUUCA0eHggZXJyb3JzLlxuICpcbiAqIGUuZy4gNDA0XG4gKiA0MDQgcmVwcmVzZW50cyBub3QgZm91bmQsIGFuZCB0aGUgZmFsbGJhY2sgY29tcG9uZW50IHBhaXIgY29udGFpbnMgdGhlIGNvbXBvbmVudCBhbmQgaXRzIHN0eWxlcy5cbiAqXG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVVudHJhY2tlZFBhdGhuYW1lIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi11bnRyYWNrZWQnXG5pbXBvcnQge1xuICBIVFRQQWNjZXNzRXJyb3JTdGF0dXMsXG4gIGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyxcbiAgZ2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyxcbiAgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbn0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjaydcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgeyBNaXNzaW5nU2xvdENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5UHJvcHMge1xuICBub3RGb3VuZD86IFJlYWN0LlJlYWN0Tm9kZVxuICBmb3JiaWRkZW4/OiBSZWFjdC5SZWFjdE5vZGVcbiAgdW5hdXRob3JpemVkPzogUmVhY3QuUmVhY3ROb2RlXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbiAgbWlzc2luZ1Nsb3RzPzogU2V0PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wc1xuICBleHRlbmRzIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5UHJvcHMge1xuICBwYXRobmFtZTogc3RyaW5nIHwgbnVsbFxuICBtaXNzaW5nU2xvdHM/OiBTZXQ8c3RyaW5nPlxufVxuXG5pbnRlcmZhY2UgSFRUUEFjY2Vzc0JvdW5kYXJ5U3RhdGUge1xuICB0cmlnZ2VyZWRTdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxuICBwcmV2aW91c1BhdGhuYW1lOiBzdHJpbmcgfCBudWxsXG59XG5cbmNsYXNzIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wcyxcbiAgSFRUUEFjY2Vzc0JvdW5kYXJ5U3RhdGVcbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHRyaWdnZXJlZFN0YXR1czogdW5kZWZpbmVkLFxuICAgICAgcHJldmlvdXNQYXRobmFtZTogcHJvcHMucGF0aG5hbWUsXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goKTogdm9pZCB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzICYmXG4gICAgICB0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5zaXplID4gMCAmJlxuICAgICAgLy8gQSBtaXNzaW5nIGNoaWxkcmVuIHNsb3QgaXMgdGhlIHR5cGljYWwgbm90LWZvdW5kIGNhc2UsIHNvIG5vIG5lZWQgdG8gd2FyblxuICAgICAgIXRoaXMucHJvcHMubWlzc2luZ1Nsb3RzLmhhcygnY2hpbGRyZW4nKVxuICAgICkge1xuICAgICAgbGV0IHdhcm5pbmdNZXNzYWdlID1cbiAgICAgICAgJ05vIGRlZmF1bHQgY29tcG9uZW50IHdhcyBmb3VuZCBmb3IgYSBwYXJhbGxlbCByb3V0ZSByZW5kZXJlZCBvbiB0aGlzIHBhZ2UuIEZhbGxpbmcgYmFjayB0byBuZWFyZXN0IE5vdEZvdW5kIGJvdW5kYXJ5LlxcbicgK1xuICAgICAgICAnTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9wYXJhbGxlbC1yb3V0ZXMjZGVmYXVsdGpzXFxuXFxuJ1xuXG4gICAgICBjb25zdCBmb3JtYXR0ZWRTbG90cyA9IEFycmF5LmZyb20odGhpcy5wcm9wcy5taXNzaW5nU2xvdHMpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpXG4gICAgICAgIC5tYXAoKHNsb3QpID0+IGBAJHtzbG90fWApXG4gICAgICAgIC5qb2luKCcsICcpXG5cbiAgICAgIHdhcm5pbmdNZXNzYWdlICs9ICdNaXNzaW5nIHNsb3RzOiAnICsgZm9ybWF0dGVkU2xvdHNcblxuICAgICAgd2Fybk9uY2Uod2FybmluZ01lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcjogYW55KSB7XG4gICAgaWYgKGlzSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IoZXJyb3IpKSB7XG4gICAgICBjb25zdCBodHRwU3RhdHVzID0gZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzKGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzOiBodHRwU3RhdHVzLFxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZS10aHJvdyBpZiBlcnJvciBpcyBub3QgZm9yIDQwNFxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgIHByb3BzOiBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMsXG4gICAgc3RhdGU6IEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlXG4gICk6IEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlIHwgbnVsbCB7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyByZXNldCBvZiB0aGUgZXJyb3IgYm91bmRhcnkgd2hlbiBhIG5hdmlnYXRpb24gaGFwcGVucy5cbiAgICAgKiBFbnN1cmVzIHRoZSBlcnJvciBib3VuZGFyeSBkb2VzIG5vdCBzdGF5IGVuYWJsZWQgd2hlbiBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UuXG4gICAgICogQXBwcm9hY2ggb2Ygc2V0U3RhdGUgaW4gcmVuZGVyIGlzIHNhZmUgYXMgaXQgY2hlY2tzIHRoZSBwcmV2aW91cyBwYXRobmFtZSBhbmQgdGhlbiBvdmVycmlkZXNcbiAgICAgKiBpdCBhcyBvdXRsaW5lZCBpbiBodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QvdXNlU3RhdGUjc3RvcmluZy1pbmZvcm1hdGlvbi1mcm9tLXByZXZpb3VzLXJlbmRlcnNcbiAgICAgKi9cbiAgICBpZiAocHJvcHMucGF0aG5hbWUgIT09IHN0YXRlLnByZXZpb3VzUGF0aG5hbWUgJiYgc3RhdGUudHJpZ2dlcmVkU3RhdHVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmlnZ2VyZWRTdGF0dXM6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJldmlvdXNQYXRobmFtZTogcHJvcHMucGF0aG5hbWUsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0cmlnZ2VyZWRTdGF0dXM6IHN0YXRlLnRyaWdnZXJlZFN0YXR1cyxcbiAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IG5vdEZvdW5kLCBmb3JiaWRkZW4sIHVuYXV0aG9yaXplZCwgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IHRyaWdnZXJlZFN0YXR1cyB9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IGVycm9yQ29tcG9uZW50cyA9IHtcbiAgICAgIFtIVFRQQWNjZXNzRXJyb3JTdGF0dXMuTk9UX0ZPVU5EXTogbm90Rm91bmQsXG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLkZPUkJJRERFTl06IGZvcmJpZGRlbixcbiAgICAgIFtIVFRQQWNjZXNzRXJyb3JTdGF0dXMuVU5BVVRIT1JJWkVEXTogdW5hdXRob3JpemVkLFxuICAgIH1cblxuICAgIGlmICh0cmlnZ2VyZWRTdGF0dXMpIHtcbiAgICAgIGNvbnN0IGlzTm90Rm91bmQgPVxuICAgICAgICB0cmlnZ2VyZWRTdGF0dXMgPT09IEhUVFBBY2Nlc3NFcnJvclN0YXR1cy5OT1RfRk9VTkQgJiYgbm90Rm91bmRcbiAgICAgIGNvbnN0IGlzRm9yYmlkZGVuID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuRk9SQklEREVOICYmIGZvcmJpZGRlblxuICAgICAgY29uc3QgaXNVbmF1dGhvcml6ZWQgPVxuICAgICAgICB0cmlnZ2VyZWRTdGF0dXMgPT09IEhUVFBBY2Nlc3NFcnJvclN0YXR1cy5VTkFVVEhPUklaRUQgJiYgdW5hdXRob3JpemVkXG5cbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2hlZCBib3VuZGFyeSBpbiB0aGlzIGxheWVyLCBrZWVwIHRocm93aW5nIHRoZSBlcnJvciBieSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuXG4gICAgICBpZiAoIShpc05vdEZvdW5kIHx8IGlzRm9yYmlkZGVuIHx8IGlzVW5hdXRob3JpemVkKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwicm9ib3RzXCIgY29udGVudD1cIm5vaW5kZXhcIiAvPlxuICAgICAgICAgIHtwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAoXG4gICAgICAgICAgICA8bWV0YVxuICAgICAgICAgICAgICBuYW1lPVwiYm91bmRhcnktbmV4dC1lcnJvclwiXG4gICAgICAgICAgICAgIGNvbnRlbnQ9e2dldEFjY2Vzc0ZhbGxiYWNrRXJyb3JUeXBlQnlTdGF0dXModHJpZ2dlcmVkU3RhdHVzKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgICB7ZXJyb3JDb21wb25lbnRzW3RyaWdnZXJlZFN0YXR1c119XG4gICAgICAgIDwvPlxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSh7XG4gIG5vdEZvdW5kLFxuICBmb3JiaWRkZW4sXG4gIHVuYXV0aG9yaXplZCxcbiAgY2hpbGRyZW4sXG59OiBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzKSB7XG4gIC8vIFdoZW4gd2UncmUgcmVuZGVyaW5nIHRoZSBtaXNzaW5nIHBhcmFtcyBzaGVsbCwgdGhpcyB3aWxsIHJldHVybiBudWxsLiBUaGlzXG4gIC8vIGlzIGJlY2F1c2Ugd2Ugd29uJ3QgYmUgcmVuZGVyaW5nIGFueSBub3QgZm91bmQgYm91bmRhcmllcyBvciBlcnJvclxuICAvLyBib3VuZGFyaWVzIGZvciB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwuIFdoZW4gdGhpcyBydW5zIG9uIHRoZSBjbGllbnRcbiAgLy8gKHdoZXJlIHRoZXNlIGVycm9yIGNhbiBvY2N1ciksIHdlIHdpbGwgZ2V0IHRoZSBjb3JyZWN0IHBhdGhuYW1lLlxuICBjb25zdCBwYXRobmFtZSA9IHVzZVVudHJhY2tlZFBhdGhuYW1lKClcbiAgY29uc3QgbWlzc2luZ1Nsb3RzID0gdXNlQ29udGV4dChNaXNzaW5nU2xvdENvbnRleHQpXG4gIGNvbnN0IGhhc0Vycm9yRmFsbGJhY2sgPSAhIShub3RGb3VuZCB8fCBmb3JiaWRkZW4gfHwgdW5hdXRob3JpemVkKVxuXG4gIGlmIChoYXNFcnJvckZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5XG4gICAgICAgIHBhdGhuYW1lPXtwYXRobmFtZX1cbiAgICAgICAgbm90Rm91bmQ9e25vdEZvdW5kfVxuICAgICAgICBmb3JiaWRkZW49e2ZvcmJpZGRlbn1cbiAgICAgICAgdW5hdXRob3JpemVkPXt1bmF1dGhvcml6ZWR9XG4gICAgICAgIG1pc3NpbmdTbG90cz17bWlzc2luZ1Nsb3RzfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnk+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIDw+e2NoaWxkcmVufTwvPlxufVxuIl0sIm5hbWVzIjpbIkhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IiwiSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeSIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcm9wcyIsIm1pc3NpbmdTbG90cyIsInNpemUiLCJoYXMiLCJ3YXJuaW5nTWVzc2FnZSIsImZvcm1hdHRlZFNsb3RzIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsIm1hcCIsInNsb3QiLCJqb2luIiwid2Fybk9uY2UiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJlcnJvciIsImlzSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IiLCJodHRwU3RhdHVzIiwiZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzIiwidHJpZ2dlcmVkU3RhdHVzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwic3RhdGUiLCJwYXRobmFtZSIsInByZXZpb3VzUGF0aG5hbWUiLCJ1bmRlZmluZWQiLCJyZW5kZXIiLCJub3RGb3VuZCIsImZvcmJpZGRlbiIsInVuYXV0aG9yaXplZCIsImNoaWxkcmVuIiwiZXJyb3JDb21wb25lbnRzIiwiSFRUUEFjY2Vzc0Vycm9yU3RhdHVzIiwiTk9UX0ZPVU5EIiwiRk9SQklEREVOIiwiVU5BVVRIT1JJWkVEIiwiaXNOb3RGb3VuZCIsImlzRm9yYmlkZGVuIiwiaXNVbmF1dGhvcml6ZWQiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzIiwiY29uc3RydWN0b3IiLCJ1c2VVbnRyYWNrZWRQYXRobmFtZSIsInVzZUNvbnRleHQiLCJNaXNzaW5nU2xvdENvbnRleHQiLCJoYXNFcnJvckZhbGxiYWNrIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/links.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/components/links.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    unmountLinkInstance: function() {\n        return unmountLinkInstance;\n    }\n});\nconst _actionqueue = __webpack_require__(/*! ../../shared/lib/router/action-queue */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/action-queue.js\");\nconst _approuter = __webpack_require__(/*! ./app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst links = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst visibleLinks = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction mountLinkInstance(element, href, router, kind) {\n    let prefetchUrl = null;\n    try {\n        prefetchUrl = (0, _approuter.createPrefetchURL)(href);\n        if (prefetchUrl === null) {\n            // We only track the link if it's prefetchable. For example, this excludes\n            // links to external URLs.\n            return;\n        }\n    } catch (e) {\n        // createPrefetchURL sometimes throws an error if an invalid URL is\n        // provided, though I'm not sure if it's actually necessary.\n        // TODO: Consider removing the throw from the inner function, or change it\n        // to reportError. Or maybe the error isn't even necessary for automatic\n        // prefetches, just navigations.\n        const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n        reportErrorFn(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\");\n        return;\n    }\n    const instance = {\n        prefetchHref: prefetchUrl.href,\n        router,\n        kind,\n        isVisible: false,\n        wasHoveredOrTouched: false,\n        prefetchTask: null,\n        cacheVersion: -1\n    };\n    const existingInstance = links.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountLinkInstance(element);\n    }\n    links.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction unmountLinkInstance(element) {\n    const instance = links.get(element);\n    if (instance !== undefined) {\n        links.delete(element);\n        visibleLinks.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (true) {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = links.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        visibleLinks.add(instance);\n    } else {\n        visibleLinks.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance);\n}\nfunction onNavigationIntent(element) {\n    const instance = links.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        instance.wasHoveredOrTouched = true;\n        rescheduleLinkPrefetch(instance);\n    }\n}\nfunction rescheduleLinkPrefetch(instance) {\n    const existingPrefetchTask = instance.prefetchTask;\n    if (!instance.isVisible) {\n        // Cancel any in-progress prefetch task. (If it already finished then this\n        // is a no-op.)\n        if (existingPrefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);\n        }\n        // We don't need to reset the prefetchTask to null upon cancellation; an\n        // old task object can be rescheduled with bumpPrefetchTask. This is a\n        // micro-optimization but also makes the code simpler (don't need to\n        // worry about whether an old task object is stale).\n        return;\n    }\n    if (true) {\n        // The old prefetch implementation does not have different priority levels.\n        // Just schedule a new prefetch task.\n        prefetchWithOldCacheImplementation(instance);\n        return;\n    }\n    // In the Segment Cache implementation, we assign a higher priority level to\n    // links that were at one point hovered or touched. Since the queue is last-\n    // in-first-out, the highest priority Link is whichever one was hovered last.\n    //\n    // We also increase the relative priority of links whenever they re-enter the\n    // viewport, as if they were being scheduled for the first time.\n    const priority = instance.wasHoveredOrTouched ? _segmentcache.PrefetchPriority.Intent : _segmentcache.PrefetchPriority.Default;\n    if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const appRouterState = (0, _actionqueue.getCurrentAppRouterState)();\n        if (appRouterState !== null) {\n            const nextUrl = appRouterState.nextUrl;\n            const treeAtTimeOfPrefetch = appRouterState.tree;\n            const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n            instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.kind === _routerreducertypes.PrefetchKind.FULL, priority);\n            instance.cacheVersion = (0, _segmentcache.getCurrentCacheVersion)();\n        }\n    } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        (0, _segmentcache.bumpPrefetchTask)(existingPrefetchTask, priority);\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    const currentCacheVersion = (0, _segmentcache.getCurrentCacheVersion)();\n    for (const instance of visibleLinks){\n        const task = instance.prefetchTask;\n        if (task !== null && instance.cacheVersion === currentCacheVersion && task.key.nextUrl === nextUrl && task.treeAtTimeOfPrefetch === tree) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n        const priority = instance.wasHoveredOrTouched ? _segmentcache.PrefetchPriority.Intent : _segmentcache.PrefetchPriority.Default;\n        instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.kind === _routerreducertypes.PrefetchKind.FULL, priority);\n        instance.cacheVersion = (0, _segmentcache.getCurrentCacheVersion)();\n    }\n}\nfunction prefetchWithOldCacheImplementation(instance) {\n    // This is the path used when the Segment Cache is not enabled.\n    if (false) {}\n    const doPrefetch = async ()=>{\n        // note that `appRouter.prefetch()` is currently sync,\n        // so we have to wrap this call in an async function to be able to catch() errors below.\n        return instance.router.prefetch(instance.prefetchHref, {\n            kind: instance.kind\n        });\n    };\n    // Prefetch the page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=links.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGlua3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBc0RnQkEsaUJBQWlCO2VBQWpCQTs7SUEyRUFDLHVCQUF1QjtlQUF2QkE7O0lBeUJBQyxrQkFBa0I7ZUFBbEJBOztJQWtFQUMsZ0JBQWdCO2VBQWhCQTs7SUFwSEFDLG1CQUFtQjtlQUFuQkE7Ozt5Q0F0R3lCO3VDQUNQO2dEQUNMOzBDQUNVO0FBOEJ2QywyRUFBMkU7QUFDM0UsbUVBQW1FO0FBQ25FLE1BQU1DLFFBQ0osT0FBT0MsWUFBWSxhQUFhLElBQUlBLFlBQVksSUFBSUM7QUFFdEQsNkVBQTZFO0FBQzdFLDRFQUE0RTtBQUM1RSwwRUFBMEU7QUFDMUUsaUJBQWlCO0FBQ2pCLE1BQU1DLGVBQWtDLElBQUlDO0FBRTVDLDBFQUEwRTtBQUMxRSxNQUFNQyxXQUNKLE9BQU9DLHlCQUF5QixhQUM1QixJQUFJQSxxQkFBcUJDLGlCQUFpQjtJQUN4Q0MsWUFBWTtBQUNkLEtBQ0E7QUFFQyxTQUFTYixrQkFDZGMsT0FBb0IsRUFDcEJDLElBQVksRUFDWkMsTUFBeUIsRUFDekJDLElBQTJDO0lBRTNDLElBQUlDLGNBQTBCO0lBQzlCLElBQUk7UUFDRkEsY0FBY0MsQ0FBQUEsR0FBQUEsV0FBQUEsaUJBQUFBLEVBQWtCSjtRQUNoQyxJQUFJRyxnQkFBZ0IsTUFBTTtZQUN4QiwwRUFBMEU7WUFDMUUsMEJBQTBCO1lBQzFCO1FBQ0Y7SUFDRixFQUFFLFVBQU07UUFDTixtRUFBbUU7UUFDbkUsNERBQTREO1FBQzVELDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsZ0NBQWdDO1FBQ2hDLE1BQU1FLGdCQUNKLE9BQU9DLGdCQUFnQixhQUFhQSxjQUFjQyxRQUFRQyxLQUFLO1FBQ2pFSCxjQUNHLHNCQUFtQkwsT0FBSztRQUUzQjtJQUNGO0lBRUEsTUFBTVMsV0FBeUI7UUFDN0JDLGNBQWNQLFlBQVlI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QjtRQUNyQjtRQUNBLE1BQU1SLFdBQVdDLENBQUFBLEdBQUFBLGNBQUFBLGNBQUFBLEVBQWVwQyxTQUFTQyxZQUFZLEVBQUUrQjtRQUN2RCxNQUFNTixXQUFXMUIsU0FBU0csbUJBQW1CLEdBQ3pDd0IsY0FBQUEsZ0JBQWdCLENBQUNDLE1BQU0sR0FDdkJELGNBQUFBLGdCQUFnQixDQUFDRSxPQUFPO1FBQzVCN0IsU0FBU0ksWUFBWSxHQUFHaUMsQ0FBQUEsR0FBQUEsY0FBQUEsb0JBQUFBLEVBQ3RCRixVQUNBRCxNQUNBbEMsU0FBU1AsSUFBSSxLQUFLNkMsb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUNuQ2I7UUFFRjFCLFNBQVNLLFlBQVksR0FBR21DLENBQUFBLEdBQUFBLGNBQUFBLHNCQUFzQjtJQUNoRDtBQUNGO0FBRUEsU0FBU2YsbUNBQW1DekIsUUFBc0I7SUFDaEUsK0RBQStEO0lBQy9ELElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUVELE1BQU04QyxhQUFhO1FBQ2pCLHNEQUFzRDtRQUN0RCx3RkFBd0Y7UUFDeEYsT0FBTzlDLFNBQVNSLE1BQU0sQ0FBQ3VELFFBQVEsQ0FBQy9DLFNBQVNDLFlBQVksRUFBRTtZQUNyRFIsTUFBTU8sU0FBU1AsSUFBSTtRQUNyQjtJQUNGO0lBRUEsa0RBQWtEO0lBQ2xELDBEQUEwRDtJQUMxRCxzREFBc0Q7SUFDdEQseURBQXlEO0lBQ3pEcUQsYUFBYUUsS0FBSyxDQUFDLENBQUNDO1FBQ2xCLElBbkpBLElBbUp3QixFQUFtQjtZQUN6QyxxQ0FBcUM7WUFDckMsTUFBTUE7UUFDUjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWlraV9cXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxsaW5rcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlckluc3RhbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci9hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBjcmVhdGVQcmVmZXRjaFVSTCB9IGZyb20gJy4vYXBwLXJvdXRlcidcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uIH0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVLZXkgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5pbXBvcnQge1xuICB0eXBlIFByZWZldGNoVGFzayxcbiAgUHJlZmV0Y2hQcmlvcml0eSxcbiAgc2NoZWR1bGVQcmVmZXRjaFRhc2sgYXMgc2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrLFxuICBjYW5jZWxQcmVmZXRjaFRhc2ssXG4gIGJ1bXBQcmVmZXRjaFRhc2ssXG59IGZyb20gJy4vc2VnbWVudC1jYWNoZSdcblxudHlwZSBMaW5rRWxlbWVudCA9IEhUTUxBbmNob3JFbGVtZW50IHwgU1ZHQUVsZW1lbnQgfCBIVE1MRm9ybUVsZW1lbnRcblxudHlwZSBMaW5rSW5zdGFuY2UgPSB7XG4gIHJvdXRlcjogQXBwUm91dGVySW5zdGFuY2VcbiAga2luZDogUHJlZmV0Y2hLaW5kLkFVVE8gfCBQcmVmZXRjaEtpbmQuRlVMTFxuICBwcmVmZXRjaEhyZWY6IHN0cmluZ1xuXG4gIGlzVmlzaWJsZTogYm9vbGVhblxuICB3YXNIb3ZlcmVkT3JUb3VjaGVkOiBib29sZWFuXG5cbiAgLy8gVGhlIG1vc3QgcmVjZW50bHkgaW5pdGlhdGVkIHByZWZldGNoIHRhc2suIEl0IG1heSBvciBtYXkgbm90IGhhdmVcbiAgLy8gYWxyZWFkeSBjb21wbGV0ZWQuICBUaGUgc2FtZSBwcmVmZXRjaCB0YXNrIG9iamVjdCBjYW4gYmUgcmV1c2VkIGFjcm9zc1xuICAvLyBtdWx0aXBsZSBwcmVmZXRjaGVzIG9mIHRoZSBzYW1lIGxpbmsuXG4gIHByZWZldGNoVGFzazogUHJlZmV0Y2hUYXNrIHwgbnVsbFxuXG4gIC8vIFRoZSBjYWNoZSB2ZXJzaW9uIGF0IHRoZSB0aW1lIHRoZSB0YXNrIHdhcyBpbml0aWF0ZWQuIFRoaXMgaXMgdXNlZCB0b1xuICAvLyBkZXRlcm1pbmUgaWYgdGhlIGNhY2hlIHdhcyBpbnZhbGlkYXRlZCBzaW5jZSB0aGUgdGFzayB3YXMgaW5pdGlhdGVkLlxuICBjYWNoZVZlcnNpb246IG51bWJlclxufVxuXG4vLyBVc2UgYSBXZWFrTWFwIHRvIGFzc29jaWF0ZSBhIExpbmsgaW5zdGFuY2Ugd2l0aCBpdHMgRE9NIGVsZW1lbnQuIFRoaXMgaXNcbi8vIHVzZWQgYnkgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyIHRvIHRyYWNrIHRoZSBsaW5rJ3MgdmlzaWJpbGl0eS5cbmNvbnN0IGxpbmtzOiBXZWFrTWFwPExpbmtFbGVtZW50LCBMaW5rSW5zdGFuY2U+IHwgTWFwPEVsZW1lbnQsIExpbmtJbnN0YW5jZT4gPVxuICB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwKClcblxuLy8gQSBTZXQgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGxpbmtzLiBXZSByZS1wcmVmZXRjaCB2aXNpYmxlIGxpbmtzIGFmdGVyIGFcbi8vIGNhY2hlIGludmFsaWRhdGlvbiwgb3Igd2hlbiB0aGUgY3VycmVudCBVUkwgY2hhbmdlcy4gSXQncyBhIHNlcGFyYXRlIGRhdGFcbi8vIHN0cnVjdHVyZSBmcm9tIHRoZSBXZWFrTWFwIGFib3ZlIGJlY2F1c2Ugb25seSB0aGUgdmlzaWJsZSBsaW5rcyBuZWVkIHRvXG4vLyBiZSBlbnVtZXJhdGVkLlxuY29uc3QgdmlzaWJsZUxpbmtzOiBTZXQ8TGlua0luc3RhbmNlPiA9IG5ldyBTZXQoKVxuXG4vLyBBIHNpbmdsZSBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbnN0YW5jZSBzaGFyZWQgYnkgYWxsIDxMaW5rPiBjb21wb25lbnRzLlxuY29uc3Qgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyIHwgbnVsbCA9XG4gIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZUludGVyc2VjdCwge1xuICAgICAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICAgICAgfSlcbiAgICA6IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50TGlua0luc3RhbmNlKFxuICBlbGVtZW50OiBMaW5rRWxlbWVudCxcbiAgaHJlZjogc3RyaW5nLFxuICByb3V0ZXI6IEFwcFJvdXRlckluc3RhbmNlLFxuICBraW5kOiBQcmVmZXRjaEtpbmQuQVVUTyB8IFByZWZldGNoS2luZC5GVUxMXG4pIHtcbiAgbGV0IHByZWZldGNoVXJsOiBVUkwgfCBudWxsID0gbnVsbFxuICB0cnkge1xuICAgIHByZWZldGNoVXJsID0gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZilcbiAgICBpZiAocHJlZmV0Y2hVcmwgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIG9ubHkgdHJhY2sgdGhlIGxpbmsgaWYgaXQncyBwcmVmZXRjaGFibGUuIEZvciBleGFtcGxlLCB0aGlzIGV4Y2x1ZGVzXG4gICAgICAvLyBsaW5rcyB0byBleHRlcm5hbCBVUkxzLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBjcmVhdGVQcmVmZXRjaFVSTCBzb21ldGltZXMgdGhyb3dzIGFuIGVycm9yIGlmIGFuIGludmFsaWQgVVJMIGlzXG4gICAgLy8gcHJvdmlkZWQsIHRob3VnaCBJJ20gbm90IHN1cmUgaWYgaXQncyBhY3R1YWxseSBuZWNlc3NhcnkuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHRocm93IGZyb20gdGhlIGlubmVyIGZ1bmN0aW9uLCBvciBjaGFuZ2UgaXRcbiAgICAvLyB0byByZXBvcnRFcnJvci4gT3IgbWF5YmUgdGhlIGVycm9yIGlzbid0IGV2ZW4gbmVjZXNzYXJ5IGZvciBhdXRvbWF0aWNcbiAgICAvLyBwcmVmZXRjaGVzLCBqdXN0IG5hdmlnYXRpb25zLlxuICAgIGNvbnN0IHJlcG9ydEVycm9yRm4gPVxuICAgICAgdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID8gcmVwb3J0RXJyb3IgOiBjb25zb2xlLmVycm9yXG4gICAgcmVwb3J0RXJyb3JGbihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgaW5zdGFuY2U6IExpbmtJbnN0YW5jZSA9IHtcbiAgICBwcmVmZXRjaEhyZWY6IHByZWZldGNoVXJsLmhyZWYsXG4gICAgcm91dGVyLFxuICAgIGtpbmQsXG4gICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICB3YXNIb3ZlcmVkT3JUb3VjaGVkOiBmYWxzZSxcbiAgICBwcmVmZXRjaFRhc2s6IG51bGwsXG4gICAgY2FjaGVWZXJzaW9uOiAtMSxcbiAgfVxuICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gbGlua3MuZ2V0KGVsZW1lbnQpXG4gIGlmIChleGlzdGluZ0luc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSBlYWNoIDxMaW5rPiBjb21wb25lbnQgc2hvdWxkIGhhdmUgaXRzIG93blxuICAgIC8vIGFuY2hvciB0YWcgaW5zdGFuY2UsIGJ1dCBpdCdzIGRlZmVuc2l2ZSBjb2RpbmcgdG8gYXZvaWQgYSBtZW1vcnkgbGVhayBpblxuICAgIC8vIGNhc2UgdGhlcmUncyBhIGxvZ2ljYWwgZXJyb3Igc29tZXdoZXJlIGVsc2UuXG4gICAgdW5tb3VudExpbmtJbnN0YW5jZShlbGVtZW50KVxuICB9XG4gIGxpbmtzLnNldChlbGVtZW50LCBpbnN0YW5jZSlcbiAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50TGlua0luc3RhbmNlKGVsZW1lbnQ6IExpbmtFbGVtZW50KSB7XG4gIGNvbnN0IGluc3RhbmNlID0gbGlua3MuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGlua3MuZGVsZXRlKGVsZW1lbnQpXG4gICAgdmlzaWJsZUxpbmtzLmRlbGV0ZShpbnN0YW5jZSlcbiAgICBjb25zdCBwcmVmZXRjaFRhc2sgPSBpbnN0YW5jZS5wcmVmZXRjaFRhc2tcbiAgICBpZiAocHJlZmV0Y2hUYXNrICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxQcmVmZXRjaFRhc2socHJlZmV0Y2hUYXNrKVxuICAgIH1cbiAgfVxuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3QoZW50cmllczogQXJyYXk8SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeT4pIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gU29tZSBleHRyZW1lbHkgb2xkIGJyb3dzZXJzIG9yIHBvbHlmaWxscyBkb24ndCByZWxpYWJseSBzdXBwb3J0XG4gICAgLy8gaXNJbnRlcnNlY3Rpbmcgc28gd2UgY2hlY2sgaW50ZXJzZWN0aW9uUmF0aW8gaW5zdGVhZC4gKERvIHdlIGNhcmU/IE5vdFxuICAgIC8vIHJlYWxseS4gQnV0IHdoYXRldmVyIHRoaXMgaXMgZmluZS4pXG4gICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwXG4gICAgb25MaW5rVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkudGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50LCBpc1Zpc2libGUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTGlua1Zpc2liaWxpdHlDaGFuZ2VkKFxuICBlbGVtZW50OiBMaW5rRWxlbWVudCxcbiAgaXNWaXNpYmxlOiBib29sZWFuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBQcmVmZXRjaGluZyBvbiB2aWV3cG9ydCBpcyBkaXNhYmxlZCBpbiBkZXZlbG9wbWVudCBmb3IgcGVyZm9ybWFuY2VcbiAgICAvLyByZWFzb25zLCBiZWNhdXNlIGl0IHJlcXVpcmVzIGNvbXBpbGluZyB0aGUgdGFyZ2V0IHBhZ2UuXG4gICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgcmUtZW5hYmxpbmcgdGhpcy5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGluc3RhbmNlID0gbGlua3MuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpbnN0YW5jZS5pc1Zpc2libGUgPSBpc1Zpc2libGVcbiAgaWYgKGlzVmlzaWJsZSkge1xuICAgIHZpc2libGVMaW5rcy5hZGQoaW5zdGFuY2UpXG4gIH0gZWxzZSB7XG4gICAgdmlzaWJsZUxpbmtzLmRlbGV0ZShpbnN0YW5jZSlcbiAgfVxuICByZXNjaGVkdWxlTGlua1ByZWZldGNoKGluc3RhbmNlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25OYXZpZ2F0aW9uSW50ZW50KGVsZW1lbnQ6IEhUTUxBbmNob3JFbGVtZW50IHwgU1ZHQUVsZW1lbnQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBsaW5rcy5nZXQoZWxlbWVudClcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBQcmVmZXRjaCB0aGUgbGluayBvbiBob3Zlci90b3VjaHN0YXJ0LlxuICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGluc3RhbmNlLndhc0hvdmVyZWRPclRvdWNoZWQgPSB0cnVlXG4gICAgcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChpbnN0YW5jZSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNjaGVkdWxlTGlua1ByZWZldGNoKGluc3RhbmNlOiBMaW5rSW5zdGFuY2UpIHtcbiAgY29uc3QgZXhpc3RpbmdQcmVmZXRjaFRhc2sgPSBpbnN0YW5jZS5wcmVmZXRjaFRhc2tcblxuICBpZiAoIWluc3RhbmNlLmlzVmlzaWJsZSkge1xuICAgIC8vIENhbmNlbCBhbnkgaW4tcHJvZ3Jlc3MgcHJlZmV0Y2ggdGFzay4gKElmIGl0IGFscmVhZHkgZmluaXNoZWQgdGhlbiB0aGlzXG4gICAgLy8gaXMgYSBuby1vcC4pXG4gICAgaWYgKGV4aXN0aW5nUHJlZmV0Y2hUYXNrICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxQcmVmZXRjaFRhc2soZXhpc3RpbmdQcmVmZXRjaFRhc2spXG4gICAgfVxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVzZXQgdGhlIHByZWZldGNoVGFzayB0byBudWxsIHVwb24gY2FuY2VsbGF0aW9uOyBhblxuICAgIC8vIG9sZCB0YXNrIG9iamVjdCBjYW4gYmUgcmVzY2hlZHVsZWQgd2l0aCBidW1wUHJlZmV0Y2hUYXNrLiBUaGlzIGlzIGFcbiAgICAvLyBtaWNyby1vcHRpbWl6YXRpb24gYnV0IGFsc28gbWFrZXMgdGhlIGNvZGUgc2ltcGxlciAoZG9uJ3QgbmVlZCB0b1xuICAgIC8vIHdvcnJ5IGFib3V0IHdoZXRoZXIgYW4gb2xkIHRhc2sgb2JqZWN0IGlzIHN0YWxlKS5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgLy8gVGhlIG9sZCBwcmVmZXRjaCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBoYXZlIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMuXG4gICAgLy8gSnVzdCBzY2hlZHVsZSBhIG5ldyBwcmVmZXRjaCB0YXNrLlxuICAgIHByZWZldGNoV2l0aE9sZENhY2hlSW1wbGVtZW50YXRpb24oaW5zdGFuY2UpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBJbiB0aGUgU2VnbWVudCBDYWNoZSBpbXBsZW1lbnRhdGlvbiwgd2UgYXNzaWduIGEgaGlnaGVyIHByaW9yaXR5IGxldmVsIHRvXG4gIC8vIGxpbmtzIHRoYXQgd2VyZSBhdCBvbmUgcG9pbnQgaG92ZXJlZCBvciB0b3VjaGVkLiBTaW5jZSB0aGUgcXVldWUgaXMgbGFzdC1cbiAgLy8gaW4tZmlyc3Qtb3V0LCB0aGUgaGlnaGVzdCBwcmlvcml0eSBMaW5rIGlzIHdoaWNoZXZlciBvbmUgd2FzIGhvdmVyZWQgbGFzdC5cbiAgLy9cbiAgLy8gV2UgYWxzbyBpbmNyZWFzZSB0aGUgcmVsYXRpdmUgcHJpb3JpdHkgb2YgbGlua3Mgd2hlbmV2ZXIgdGhleSByZS1lbnRlciB0aGVcbiAgLy8gdmlld3BvcnQsIGFzIGlmIHRoZXkgd2VyZSBiZWluZyBzY2hlZHVsZWQgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICBjb25zdCBwcmlvcml0eSA9IGluc3RhbmNlLndhc0hvdmVyZWRPclRvdWNoZWRcbiAgICA/IFByZWZldGNoUHJpb3JpdHkuSW50ZW50XG4gICAgOiBQcmVmZXRjaFByaW9yaXR5LkRlZmF1bHRcbiAgaWYgKGV4aXN0aW5nUHJlZmV0Y2hUYXNrID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhdGUgYSBwcmVmZXRjaCB0YXNrLlxuICAgIGNvbnN0IGFwcFJvdXRlclN0YXRlID0gZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlKClcbiAgICBpZiAoYXBwUm91dGVyU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5leHRVcmwgPSBhcHBSb3V0ZXJTdGF0ZS5uZXh0VXJsXG4gICAgICBjb25zdCB0cmVlQXRUaW1lT2ZQcmVmZXRjaCA9IGFwcFJvdXRlclN0YXRlLnRyZWVcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlQ2FjaGVLZXkoaW5zdGFuY2UucHJlZmV0Y2hIcmVmLCBuZXh0VXJsKVxuICAgICAgaW5zdGFuY2UucHJlZmV0Y2hUYXNrID0gc2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrKFxuICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2gsXG4gICAgICAgIGluc3RhbmNlLmtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMLFxuICAgICAgICBwcmlvcml0eVxuICAgICAgKVxuICAgICAgaW5zdGFuY2UuY2FjaGVWZXJzaW9uID0gZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBvbGQgdGFzayBvYmplY3QgdGhhdCB3ZSBjYW4gcmVzY2hlZHVsZS4gVGhpcyBpc1xuICAgIC8vIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGNhbmNlbGluZyB0aGUgb2xkIHRhc2sgYW5kIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAgICBidW1wUHJlZmV0Y2hUYXNrKGV4aXN0aW5nUHJlZmV0Y2hUYXNrLCBwcmlvcml0eSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGluZ1Zpc2libGVMaW5rcyhcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbikge1xuICAvLyBGb3IgZWFjaCBjdXJyZW50bHkgdmlzaWJsZSBsaW5rLCBjYW5jZWwgdGhlIGV4aXN0aW5nIHByZWZldGNoIHRhc2sgKGlmIGl0XG4gIC8vIGV4aXN0cykgYW5kIHNjaGVkdWxlIGEgbmV3IG9uZS4gVGhpcyBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBpZiBhbGwgdGhlXG4gIC8vIHZpc2libGUgbGlua3MgbGVmdCBhbmQgdGhlbiByZS1lbnRlcmVkIHRoZSB2aWV3cG9ydC5cbiAgLy9cbiAgLy8gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgTmV4dC1Vcmwgb3IgdGhlIGJhc2UgdHJlZSBjaGFuZ2VzLCBzaW5jZSB0aG9zZVxuICAvLyBtYXkgYWZmZWN0IHRoZSByZXN1bHQgb2YgYSBwcmVmZXRjaCB0YXNrLiBJdCdzIGFsc28gY2FsbGVkIGFmdGVyIGFcbiAgLy8gY2FjaGUgaW52YWxpZGF0aW9uLlxuICBjb25zdCBjdXJyZW50Q2FjaGVWZXJzaW9uID0gZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpXG4gIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgdmlzaWJsZUxpbmtzKSB7XG4gICAgY29uc3QgdGFzayA9IGluc3RhbmNlLnByZWZldGNoVGFza1xuICAgIGlmIChcbiAgICAgIHRhc2sgIT09IG51bGwgJiZcbiAgICAgIGluc3RhbmNlLmNhY2hlVmVyc2lvbiA9PT0gY3VycmVudENhY2hlVmVyc2lvbiAmJlxuICAgICAgdGFzay5rZXkubmV4dFVybCA9PT0gbmV4dFVybCAmJlxuICAgICAgdGFzay50cmVlQXRUaW1lT2ZQcmVmZXRjaCA9PT0gdHJlZVxuICAgICkge1xuICAgICAgLy8gVGhlIGNhY2hlIGhhcyBub3QgYmVlbiBpbnZhbGlkYXRlZCwgYW5kIG5vbmUgb2YgdGhlIGlucHV0cyBoYXZlXG4gICAgICAvLyBjaGFuZ2VkLiBCYWlsIG91dC5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIC8vIFNvbWV0aGluZyBjaGFuZ2VkLiBDYW5jZWwgdGhlIGV4aXN0aW5nIHByZWZldGNoIHRhc2sgYW5kIHNjaGVkdWxlIGFcbiAgICAvLyBuZXcgb25lLlxuICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxQcmVmZXRjaFRhc2sodGFzaylcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVDYWNoZUtleShpbnN0YW5jZS5wcmVmZXRjaEhyZWYsIG5leHRVcmwpXG4gICAgY29uc3QgcHJpb3JpdHkgPSBpbnN0YW5jZS53YXNIb3ZlcmVkT3JUb3VjaGVkXG4gICAgICA/IFByZWZldGNoUHJpb3JpdHkuSW50ZW50XG4gICAgICA6IFByZWZldGNoUHJpb3JpdHkuRGVmYXVsdFxuICAgIGluc3RhbmNlLnByZWZldGNoVGFzayA9IHNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayhcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgdHJlZSxcbiAgICAgIGluc3RhbmNlLmtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMLFxuICAgICAgcHJpb3JpdHlcbiAgICApXG4gICAgaW5zdGFuY2UuY2FjaGVWZXJzaW9uID0gZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hXaXRoT2xkQ2FjaGVJbXBsZW1lbnRhdGlvbihpbnN0YW5jZTogTGlua0luc3RhbmNlKSB7XG4gIC8vIFRoaXMgaXMgdGhlIHBhdGggdXNlZCB3aGVuIHRoZSBTZWdtZW50IENhY2hlIGlzIG5vdCBlbmFibGVkLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGRvUHJlZmV0Y2ggPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gbm90ZSB0aGF0IGBhcHBSb3V0ZXIucHJlZmV0Y2goKWAgaXMgY3VycmVudGx5IHN5bmMsXG4gICAgLy8gc28gd2UgaGF2ZSB0byB3cmFwIHRoaXMgY2FsbCBpbiBhbiBhc3luYyBmdW5jdGlvbiB0byBiZSBhYmxlIHRvIGNhdGNoKCkgZXJyb3JzIGJlbG93LlxuICAgIHJldHVybiBpbnN0YW5jZS5yb3V0ZXIucHJlZmV0Y2goaW5zdGFuY2UucHJlZmV0Y2hIcmVmLCB7XG4gICAgICBraW5kOiBpbnN0YW5jZS5raW5kLFxuICAgIH0pXG4gIH1cblxuICAvLyBQcmVmZXRjaCB0aGUgcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcbiAgZG9QcmVmZXRjaCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9KVxufVxuIl0sIm5hbWVzIjpbIm1vdW50TGlua0luc3RhbmNlIiwib25MaW5rVmlzaWJpbGl0eUNoYW5nZWQiLCJvbk5hdmlnYXRpb25JbnRlbnQiLCJwaW5nVmlzaWJsZUxpbmtzIiwidW5tb3VudExpbmtJbnN0YW5jZSIsImxpbmtzIiwiV2Vha01hcCIsIk1hcCIsInZpc2libGVMaW5rcyIsIlNldCIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJoYW5kbGVJbnRlcnNlY3QiLCJyb290TWFyZ2luIiwiZWxlbWVudCIsImhyZWYiLCJyb3V0ZXIiLCJraW5kIiwicHJlZmV0Y2hVcmwiLCJjcmVhdGVQcmVmZXRjaFVSTCIsInJlcG9ydEVycm9yRm4iLCJyZXBvcnRFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsImluc3RhbmNlIiwicHJlZmV0Y2hIcmVmIiwiaXNWaXNpYmxlIiwid2FzSG92ZXJlZE9yVG91Y2hlZCIsInByZWZldGNoVGFzayIsImNhY2hlVmVyc2lvbiIsImV4aXN0aW5nSW5zdGFuY2UiLCJnZXQiLCJ1bmRlZmluZWQiLCJzZXQiLCJvYnNlcnZlIiwiZGVsZXRlIiwiY2FuY2VsUHJlZmV0Y2hUYXNrIiwidW5vYnNlcnZlIiwiZW50cmllcyIsImVudHJ5IiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJ0YXJnZXQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJhZGQiLCJyZXNjaGVkdWxlTGlua1ByZWZldGNoIiwiZXhpc3RpbmdQcmVmZXRjaFRhc2siLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJwcmVmZXRjaFdpdGhPbGRDYWNoZUltcGxlbWVudGF0aW9uIiwicHJpb3JpdHkiLCJQcmVmZXRjaFByaW9yaXR5IiwiSW50ZW50IiwiRGVmYXVsdCIsImFwcFJvdXRlclN0YXRlIiwiZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlIiwibmV4dFVybCIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwidHJlZSIsImNhY2hlS2V5IiwiY3JlYXRlQ2FjaGVLZXkiLCJzY2hlZHVsZVNlZ21lbnRQcmVmZXRjaFRhc2siLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0Q3VycmVudENhY2hlVmVyc2lvbiIsImJ1bXBQcmVmZXRjaFRhc2siLCJjdXJyZW50Q2FjaGVWZXJzaW9uIiwidGFzayIsImtleSIsIndpbmRvdyIsImRvUHJlZmV0Y2giLCJwcmVmZXRjaCIsImNhdGNoIiwiZXJyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/links.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AppDevOverlay\", ({\n    enumerable: true,\n    get: function() {\n        return AppDevOverlay;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _appdevoverlayerrorboundary = __webpack_require__(/*! ./app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay-error-boundary.js\");\nconst _fontstyles = __webpack_require__(/*! ../font/font-styles */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/font/font-styles.js\");\nconst _devoverlay = __webpack_require__(/*! ../ui/dev-overlay */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/dev-overlay.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../../errors/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/use-error-handler.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../../is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nfunction readSsrError() {\n    if (typeof document === 'undefined') {\n        return null;\n    }\n    const ssrErrorTemplateTag = document.querySelector('template[data-next-error-message]');\n    if (ssrErrorTemplateTag) {\n        const message = ssrErrorTemplateTag.getAttribute('data-next-error-message');\n        const stack = ssrErrorTemplateTag.getAttribute('data-next-error-stack');\n        const digest = ssrErrorTemplateTag.getAttribute('data-next-error-digest');\n        const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n        if (digest) {\n            ;\n            error.digest = digest;\n        }\n        // Skip Next.js SSR'd internal errors that which will be handled by the error boundaries.\n        if ((0, _isnextroutererror.isNextRouterError)(error)) {\n            return null;\n        }\n        error.stack = stack || '';\n        return error;\n    }\n    return null;\n}\n// Needs to be in the same error boundary as the shell.\n// If it commits, we know we recovered from an SSR error.\n// If it doesn't commit, we errored again and React will take care of error reporting.\nfunction ReplaySsrOnlyErrors() {\n    if (true) {\n        // Need to read during render. The attributes will be gone after commit.\n        const ssrError = readSsrError();\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            if (ssrError !== null) {\n                // TODO(veil): Produces wrong Owner Stack\n                // TODO(veil): Mark as recoverable error\n                // TODO(veil): console.error\n                (0, _useerrorhandler.handleClientError)(ssrError, []);\n            }\n        }, [\n            ssrError\n        ]);\n    }\n    return null;\n}\n_c = ReplaySsrOnlyErrors;\nfunction AppDevOverlay(param) {\n    let { state, globalError, children } = param;\n    const [isErrorOverlayOpen, setIsErrorOverlayOpen] = (0, _react.useState)(false);\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {\n                globalError: globalError,\n                onError: setIsErrorOverlayOpen,\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(ReplaySsrOnlyErrors, {}),\n                    children\n                ]\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_fontstyles.FontStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_devoverlay.DevOverlay, {\n                state: state,\n                isErrorOverlayOpen: isErrorOverlayOpen,\n                setIsErrorOverlayOpen: setIsErrorOverlayOpen\n            })\n        ]\n    });\n}\n_c1 = AppDevOverlay;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-dev-overlay.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ReplaySsrOnlyErrors\");\n$RefreshReg$(_c1, \"AppDevOverlay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2FwcC1kZXYtb3ZlcmxheS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQTREZ0JBOzs7ZUFBQUE7Ozs7bUNBekRvQjt3REFDTzt3Q0FDaEI7d0NBQ0E7NkNBQ087K0NBQ0E7QUFFbEMsU0FBU0M7SUFDUCxJQUFJLE9BQU9DLGFBQWEsYUFBYTtRQUNuQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxzQkFBc0JELFNBQVNFLGFBQWEsQ0FDaEQ7SUFFRixJQUFJRCxxQkFBcUI7UUFDdkIsTUFBTUUsVUFBa0JGLG9CQUFvQkcsWUFBWSxDQUN0RDtRQUVGLE1BQU1DLFFBQVFKLG9CQUFvQkcsWUFBWSxDQUFDO1FBQy9DLE1BQU1FLFNBQVNMLG9CQUFvQkcsWUFBWSxDQUFDO1FBQ2hELE1BQU1HLFFBQVEscUJBQWtCLENBQWxCLElBQUlDLE1BQU1MLFVBQVY7bUJBQUE7d0JBQUE7MEJBQUE7UUFBaUI7UUFDL0IsSUFBSUcsUUFBUTs7WUFDUkMsTUFBY0QsTUFBTSxHQUFHQTtRQUMzQjtRQUNBLHlGQUF5RjtRQUN6RixJQUFJRyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCRixRQUFRO1lBQzVCLE9BQU87UUFDVDtRQUNBQSxNQUFNRixLQUFLLEdBQUdBLFNBQVM7UUFDdkIsT0FBT0U7SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVBLHVEQUF1RDtBQUN2RCx5REFBeUQ7QUFDekQsc0ZBQXNGO0FBQ3RGO0lBQ0UsSUFBSUksSUFBb0IsRUFBbUI7UUFDekMsd0VBQXdFO1FBQ3hFLE1BQU1HLFdBQVdmO1FBQ2pCLHNEQUFzRDtRQUN0RGdCLENBQUFBLEdBQUFBLE9BQUFBLFNBQUFBLEVBQVU7WUFDUixJQUFJRCxhQUFhLE1BQU07Z0JBQ3JCLHlDQUF5QztnQkFDekMsd0NBQXdDO2dCQUN4Qyw0QkFBNEI7Z0JBQzVCRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQWtCRixVQUFVLEVBQUU7WUFDaEM7UUFDRixHQUFHO1lBQUNBO1NBQVM7SUFDZjtJQUVBLE9BQU87QUFDVDtLQWhCU0o7QUFrQkYsdUJBQXVCLEtBUTdCO0lBUjZCLE1BQzVCTyxLQUFLLEVBQ0xDLFdBQVcsRUFDWEMsUUFBUSxFQUtULEdBUjZCO0lBUzVCLE1BQU0sQ0FBQ0Msb0JBQW9CQyxzQkFBc0IsR0FBR0MsQ0FBQUEsR0FBQUEsT0FBQUEsUUFBQUEsRUFBUztJQUU3RCxxQkFDRTs7MEJBQ0Usc0JBQUNDLDRCQUFBQSwwQkFBMEI7Z0JBQ3pCTCxhQUFhQTtnQkFDYk0sU0FBU0g7O2tDQUVULHFCQUFDWCxxQkFBQUEsQ0FBQUE7b0JBQ0FTOzs7MEJBSUgscUJBQUNNLFlBQUFBLFVBQVU7MEJBQ1gscUJBQUNDLFlBQUFBLFVBQVU7Z0JBQ1RULE9BQU9BO2dCQUNQRyxvQkFBb0JBO2dCQUNwQkMsdUJBQXVCQTs7OztBQUkvQjtNQTlCZ0J2QiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyZWFjdC1kZXYtb3ZlcmxheVxcYXBwXFxhcHAtZGV2LW92ZXJsYXkudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgT3ZlcmxheVN0YXRlIH0gZnJvbSAnLi4vc2hhcmVkJ1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxFcnJvckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2Vycm9yLWJvdW5kYXJ5J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSB9IGZyb20gJy4vYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IHsgRm9udFN0eWxlcyB9IGZyb20gJy4uL2ZvbnQvZm9udC1zdHlsZXMnXG5pbXBvcnQgeyBEZXZPdmVybGF5IH0gZnJvbSAnLi4vdWkvZGV2LW92ZXJsYXknXG5pbXBvcnQgeyBoYW5kbGVDbGllbnRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy91c2UtZXJyb3ItaGFuZGxlcidcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi4vLi4vaXMtbmV4dC1yb3V0ZXItZXJyb3InXG5cbmZ1bmN0aW9uIHJlYWRTc3JFcnJvcigpOiBFcnJvciB8IG51bGwge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBzc3JFcnJvclRlbXBsYXRlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAndGVtcGxhdGVbZGF0YS1uZXh0LWVycm9yLW1lc3NhZ2VdJ1xuICApXG4gIGlmIChzc3JFcnJvclRlbXBsYXRlVGFnKSB7XG4gICAgY29uc3QgbWVzc2FnZTogc3RyaW5nID0gc3NyRXJyb3JUZW1wbGF0ZVRhZy5nZXRBdHRyaWJ1dGUoXG4gICAgICAnZGF0YS1uZXh0LWVycm9yLW1lc3NhZ2UnXG4gICAgKSFcbiAgICBjb25zdCBzdGFjayA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5leHQtZXJyb3Itc3RhY2snKVxuICAgIGNvbnN0IGRpZ2VzdCA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5leHQtZXJyb3ItZGlnZXN0JylcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGlmIChkaWdlc3QpIHtcbiAgICAgIDsoZXJyb3IgYXMgYW55KS5kaWdlc3QgPSBkaWdlc3RcbiAgICB9XG4gICAgLy8gU2tpcCBOZXh0LmpzIFNTUidkIGludGVybmFsIGVycm9ycyB0aGF0IHdoaWNoIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcmllcy5cbiAgICBpZiAoaXNOZXh0Um91dGVyRXJyb3IoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBlcnJvci5zdGFjayA9IHN0YWNrIHx8ICcnXG4gICAgcmV0dXJuIGVycm9yXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vLyBOZWVkcyB0byBiZSBpbiB0aGUgc2FtZSBlcnJvciBib3VuZGFyeSBhcyB0aGUgc2hlbGwuXG4vLyBJZiBpdCBjb21taXRzLCB3ZSBrbm93IHdlIHJlY292ZXJlZCBmcm9tIGFuIFNTUiBlcnJvci5cbi8vIElmIGl0IGRvZXNuJ3QgY29tbWl0LCB3ZSBlcnJvcmVkIGFnYWluIGFuZCBSZWFjdCB3aWxsIHRha2UgY2FyZSBvZiBlcnJvciByZXBvcnRpbmcuXG5mdW5jdGlvbiBSZXBsYXlTc3JPbmx5RXJyb3JzKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIE5lZWQgdG8gcmVhZCBkdXJpbmcgcmVuZGVyLiBUaGUgYXR0cmlidXRlcyB3aWxsIGJlIGdvbmUgYWZ0ZXIgY29tbWl0LlxuICAgIGNvbnN0IHNzckVycm9yID0gcmVhZFNzckVycm9yKClcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHNzckVycm9yICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE8odmVpbCk6IFByb2R1Y2VzIHdyb25nIE93bmVyIFN0YWNrXG4gICAgICAgIC8vIFRPRE8odmVpbCk6IE1hcmsgYXMgcmVjb3ZlcmFibGUgZXJyb3JcbiAgICAgICAgLy8gVE9ETyh2ZWlsKTogY29uc29sZS5lcnJvclxuICAgICAgICBoYW5kbGVDbGllbnRFcnJvcihzc3JFcnJvciwgW10pXG4gICAgICB9XG4gICAgfSwgW3NzckVycm9yXSlcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBcHBEZXZPdmVybGF5KHtcbiAgc3RhdGUsXG4gIGdsb2JhbEVycm9yLFxuICBjaGlsZHJlbixcbn06IHtcbiAgc3RhdGU6IE92ZXJsYXlTdGF0ZVxuICBnbG9iYWxFcnJvcjogW0dsb2JhbEVycm9yQ29tcG9uZW50LCBSZWFjdC5SZWFjdE5vZGVdXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbn0pIHtcbiAgY29uc3QgW2lzRXJyb3JPdmVybGF5T3Blbiwgc2V0SXNFcnJvck92ZXJsYXlPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVxuICAgICAgICBnbG9iYWxFcnJvcj17Z2xvYmFsRXJyb3J9XG4gICAgICAgIG9uRXJyb3I9e3NldElzRXJyb3JPdmVybGF5T3Blbn1cbiAgICAgID5cbiAgICAgICAgPFJlcGxheVNzck9ubHlFcnJvcnMgLz5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9BcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeT5cblxuICAgICAgey8qIEZvbnRzIGNhbiBvbmx5IGJlIGxvYWRlZCBvdXRzaWRlIHRoZSBTaGFkb3cgRE9NLiAqL31cbiAgICAgIDxGb250U3R5bGVzIC8+XG4gICAgICA8RGV2T3ZlcmxheVxuICAgICAgICBzdGF0ZT17c3RhdGV9XG4gICAgICAgIGlzRXJyb3JPdmVybGF5T3Blbj17aXNFcnJvck92ZXJsYXlPcGVufVxuICAgICAgICBzZXRJc0Vycm9yT3ZlcmxheU9wZW49e3NldElzRXJyb3JPdmVybGF5T3Blbn1cbiAgICAgIC8+XG4gICAgPC8+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJBcHBEZXZPdmVybGF5IiwicmVhZFNzckVycm9yIiwiZG9jdW1lbnQiLCJzc3JFcnJvclRlbXBsYXRlVGFnIiwicXVlcnlTZWxlY3RvciIsIm1lc3NhZ2UiLCJnZXRBdHRyaWJ1dGUiLCJzdGFjayIsImRpZ2VzdCIsImVycm9yIiwiRXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsIlJlcGxheVNzck9ubHlFcnJvcnMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJzc3JFcnJvciIsInVzZUVmZmVjdCIsImhhbmRsZUNsaWVudEVycm9yIiwic3RhdGUiLCJnbG9iYWxFcnJvciIsImNoaWxkcmVuIiwiaXNFcnJvck92ZXJsYXlPcGVuIiwic2V0SXNFcnJvck92ZXJsYXlPcGVuIiwidXNlU3RhdGUiLCJBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSIsIm9uRXJyb3IiLCJGb250U3R5bGVzIiwiRGV2T3ZlcmxheSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator.js ***!
  \*************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useSyncDevRenderIndicator\", ({\n    enumerable: true,\n    get: function() {\n        return useSyncDevRenderIndicator;\n    }\n}));\nconst NOOP = (fn)=>fn();\n_c = NOOP;\nconst useSyncDevRenderIndicator = ()=>{\n    let syncDevRenderIndicator = NOOP;\n    if (true) {\n        const { useSyncDevRenderIndicatorInternal } = __webpack_require__(/*! ./use-sync-dev-render-indicator-internal */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator-internal.js\");\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        syncDevRenderIndicator = useSyncDevRenderIndicatorInternal();\n    }\n    return syncDevRenderIndicator;\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-sync-dev-render-indicator.js.map\nvar _c;\n$RefreshReg$(_c, \"NOOP\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvdXRpbHMvZGV2LWluZGljYXRvci91c2Utc3luYy1kZXYtcmVuZGVyLWluZGljYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7OzZEQU9hQTs7O2VBQUFBOzs7QUFQYixNQUFNQyxPQUFPLENBQUNDLEtBQW1CQTs7QUFPMUIsTUFBTUYsNEJBQTRCO0lBQ3ZDLElBQUlHLHlCQUF5QkY7SUFFN0IsSUFBSUcsSUFBb0IsRUFBb0I7UUFDMUMsTUFBTSxFQUFFRyxpQ0FBaUMsRUFBRSxHQUN6Q0MsbUJBQU9BLENBQUMsZ01BQTBDO1FBRXBELHNEQUFzRDtRQUN0REwseUJBQXlCSTtJQUMzQjtJQUVBLE9BQU9KO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccmVhY3QtZGV2LW92ZXJsYXlcXHV0aWxzXFxkZXYtaW5kaWNhdG9yXFx1c2Utc3luYy1kZXYtcmVuZGVyLWluZGljYXRvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTk9PUCA9IChmbjogKCkgPT4gdm9pZCkgPT4gZm4oKVxuXG4vKipcbiAqIFJldHVybnMgYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gd3JhcCByb3V0ZXIgYWN0aW9ucy5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIHRhcCBpbnRvIHRoZSB0cmFuc2l0aW9uIHN0YXRlIG9mIHRoZSByb3V0ZXIgYXMgYW5cbiAqIGFwcHJveGltYXRpb24gb2YgUmVhY3QgcmVuZGVyIHRpbWUuXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9yID0gKCkgPT4ge1xuICBsZXQgc3luY0RldlJlbmRlckluZGljYXRvciA9IE5PT1BcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCB7IHVzZVN5bmNEZXZSZW5kZXJJbmRpY2F0b3JJbnRlcm5hbCB9ID1cbiAgICAgIHJlcXVpcmUoJy4vdXNlLXN5bmMtZGV2LXJlbmRlci1pbmRpY2F0b3ItaW50ZXJuYWwnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3VzZS1zeW5jLWRldi1yZW5kZXItaW5kaWNhdG9yLWludGVybmFsJylcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHN5bmNEZXZSZW5kZXJJbmRpY2F0b3IgPSB1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9ySW50ZXJuYWwoKVxuICB9XG5cbiAgcmV0dXJuIHN5bmNEZXZSZW5kZXJJbmRpY2F0b3Jcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTeW5jRGV2UmVuZGVySW5kaWNhdG9yIiwiTk9PUCIsImZuIiwic3luY0RldlJlbmRlckluZGljYXRvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInVzZVN5bmNEZXZSZW5kZXJJbmRpY2F0b3JJbnRlcm5hbCIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/utils/dev-indicator/use-sync-dev-render-indicator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createInitialRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nfunction createInitialRouterState(param) {\n    let { initialFlightData, initialCanonicalUrlParts, initialParallelRoutes, location, couldBeIntercepted, postponed, prerendered } = param;\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = initialCanonicalUrlParts.join('/');\n    const normalizedFlightData = (0, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[0]);\n    const { tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;\n    // For the SSR render, seed data should always be available (we only send back a `null` response\n    // in the case of a `loading` segment, pre-PPR.)\n    const rsc = initialSeedData == null ? void 0 : initialSeedData[1];\n    var _initialSeedData_;\n    const loading = (_initialSeedData_ = initialSeedData == null ? void 0 : initialSeedData[3]) != null ? _initialSeedData_ : null;\n    const cache = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: initialParallelRoutes,\n        loading\n    };\n    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    const prefetchCache = new Map();\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, initialTree, initialSeedData, initialHead, undefined);\n    }\n    var _ref;\n    const initialState = {\n        tree: initialTree,\n        cache,\n        prefetchCache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n    if (false) {}\n    return initialState;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NERBcUJnQkE7OztlQUFBQTs7OytDQWxCa0I7MkRBQ1k7Z0RBQ0c7Z0RBQ0Y7Z0RBQ087NkRBQ0c7K0NBQ2Q7QUFZcEMsU0FBU0EseUJBQXlCLEtBUVY7SUFSVSxNQUN2Q0MsaUJBQWlCLEVBQ2pCQyx3QkFBd0IsRUFDeEJDLHFCQUFxQixFQUNyQkMsUUFBUSxFQUNSQyxrQkFBa0IsRUFDbEJDLFNBQVMsRUFDVEMsV0FBVyxFQUNrQixHQVJVO0lBU3ZDLHNGQUFzRjtJQUN0RixrR0FBa0c7SUFDbEcsbUNBQW1DO0lBQ25DLE1BQU1DLHNCQUFzQk4seUJBQXlCTyxJQUFJLENBQUM7SUFDMUQsTUFBTUMsdUJBQXVCQyxDQUFBQSxHQUFBQSxtQkFBQUEsMEJBQUFBLEVBQTJCVixpQkFBaUIsQ0FBQyxFQUFFO0lBQzVFLE1BQU0sRUFDSlcsTUFBTUMsV0FBVyxFQUNqQkMsVUFBVUMsZUFBZSxFQUN6QkMsTUFBTUMsV0FBVyxFQUNsQixHQUFHUDtJQUNKLGdHQUFnRztJQUNoRyxnREFBZ0Q7SUFDaEQsTUFBTVEsTUFBTUgsbUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGVBQWlCLENBQUMsRUFBRTtRQUNoQkE7SUFBaEIsTUFBTUksVUFBVUoscUJBQUFBLG1CQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxlQUFpQixDQUFDLE9BQUUsT0FBcEJBLG9CQUF3QjtJQUV4QyxNQUFNSyxRQUFtQjtRQUN2QkMsVUFBVTtRQUNWSDtRQUNBSSxhQUFhO1FBQ2JOLE1BQU07UUFDTk8sY0FBYztRQUNkLG9KQUFvSjtRQUNwSkMsZ0JBQWdCckI7UUFDaEJnQjtJQUNGO0lBRUEsTUFBTU0sZUFDSiw2RUFBNkUscUVBQ3FFO0lBQ2xKckIsV0FFSXNCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0J0QixZQUNsQkk7SUFFTm1CLENBQUFBLEdBQUFBLGlDQUFBQSx3Q0FBQUEsRUFBeUNkLGFBQWFZO0lBRXRELE1BQU1HLGdCQUFnQixJQUFJQztJQUUxQix5RUFBeUU7SUFDekUsSUFBSTFCLDBCQUEwQixRQUFRQSxzQkFBc0IyQixJQUFJLEtBQUssR0FBRztRQUN0RUMsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUFBQSxFQUNFWCxPQUNBWSxXQUNBbkIsYUFDQUUsaUJBQ0FFLGFBQ0FlO0lBRUo7UUFxQkk7SUFuQkosTUFBTUUsZUFBZTtRQUNuQnRCLE1BQU1DO1FBQ05PO1FBQ0FRO1FBQ0FPLFNBQVM7WUFDUEMsYUFBYTtZQUNiQyxlQUFlO1lBQ2YsbUVBQW1FO1lBQ25FLGdGQUFnRjtZQUNoRkMsNEJBQTRCO1FBQzlCO1FBQ0FDLG1CQUFtQjtZQUNqQkMsT0FBTztZQUNQQyxnQkFBZ0I7WUFDaEJDLGNBQWM7WUFDZEMsY0FBYyxFQUFFO1FBQ2xCO1FBQ0FsQjtRQUNBbUIsU0FFRSxDQUFDWCxPQUFBQSxDQUFBQSxHQUFBQSxvQkFBQUEsZ0NBQUFBLEVBQWlDcEIsaUJBQWdCVCxZQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxTQUFVeUMsUUFBQUEsQ0FBUSxZQUFuRVosT0FDRDtJQUNKO0lBRUEsSUFBSWEsS0FBa0QxQyxFQUFFLEVBaUN2RDtJQUVELE9BQU84QjtBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEZsaWdodERhdGFQYXRoIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZCdcbmltcG9ydCB7IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB7IGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4vcHJlZmV0Y2gtY2FjaGUtdXRpbHMnXG5pbXBvcnQgeyBQcmVmZXRjaEtpbmQsIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5IH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMgfSBmcm9tICcuL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMnXG5pbXBvcnQgeyBnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aCB9IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhbFJvdXRlclN0YXRlUGFyYW1ldGVycyB7XG4gIGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0czogc3RyaW5nW11cbiAgaW5pdGlhbFBhcmFsbGVsUm91dGVzOiBDYWNoZU5vZGVbJ3BhcmFsbGVsUm91dGVzJ11cbiAgaW5pdGlhbEZsaWdodERhdGE6IEZsaWdodERhdGFQYXRoW11cbiAgbG9jYXRpb246IExvY2F0aW9uIHwgbnVsbFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cbiAgcG9zdHBvbmVkOiBib29sZWFuXG4gIHByZXJlbmRlcmVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoe1xuICBpbml0aWFsRmxpZ2h0RGF0YSxcbiAgaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzLFxuICBpbml0aWFsUGFyYWxsZWxSb3V0ZXMsXG4gIGxvY2F0aW9uLFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQsXG4gIHBvc3Rwb25lZCxcbiAgcHJlcmVuZGVyZWQsXG59OiBJbml0aWFsUm91dGVyU3RhdGVQYXJhbWV0ZXJzKSB7XG4gIC8vIFdoZW4gaW5pdGlhbGl6ZWQgb24gdGhlIHNlcnZlciwgdGhlIGNhbm9uaWNhbCBVUkwgaXMgcHJvdmlkZWQgYXMgYW4gYXJyYXkgb2YgcGFydHMuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgd2hlbiB0aGUgUlNDIHBheWxvYWQgc3RyZWFtZWQgdG8gdGhlIGNsaWVudCwgY3Jhd2xlcnMgZG9uJ3QgaW50ZXJwcmV0IGl0XG4gIC8vIGFzIGEgVVJMIHRoYXQgc2hvdWxkIGJlIGNyYXdsZWQuXG4gIGNvbnN0IGluaXRpYWxDYW5vbmljYWxVcmwgPSBpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMuam9pbignLycpXG4gIGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhID0gZ2V0RmxpZ2h0RGF0YVBhcnRzRnJvbVBhdGgoaW5pdGlhbEZsaWdodERhdGFbMF0pXG4gIGNvbnN0IHtcbiAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICBzZWVkRGF0YTogaW5pdGlhbFNlZWREYXRhLFxuICAgIGhlYWQ6IGluaXRpYWxIZWFkLFxuICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgLy8gRm9yIHRoZSBTU1IgcmVuZGVyLCBzZWVkIGRhdGEgc2hvdWxkIGFsd2F5cyBiZSBhdmFpbGFibGUgKHdlIG9ubHkgc2VuZCBiYWNrIGEgYG51bGxgIHJlc3BvbnNlXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgYGxvYWRpbmdgIHNlZ21lbnQsIHByZS1QUFIuKVxuICBjb25zdCByc2MgPSBpbml0aWFsU2VlZERhdGE/LlsxXVxuICBjb25zdCBsb2FkaW5nID0gaW5pdGlhbFNlZWREYXRhPy5bM10gPz8gbnVsbFxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIC8vIFRoZSBjYWNoZSBnZXRzIHNlZWRlZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlci4gYGluaXRpYWxQYXJhbGxlbFJvdXRlc2AgZW5zdXJlcyB0aGUgY2FjaGUgZnJvbSB0aGUgZmlyc3QgcmVuZGVyIGlzIHRoZXJlIGR1cmluZyB0aGUgc2Vjb25kIHJlbmRlci5cbiAgICBwYXJhbGxlbFJvdXRlczogaW5pdGlhbFBhcmFsbGVsUm91dGVzLFxuICAgIGxvYWRpbmcsXG4gIH1cblxuICBjb25zdCBjYW5vbmljYWxVcmwgPVxuICAgIC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgLy8gVGhpcyBpcyBzYWZlIHRvIGRvIGFzIGNhbm9uaWNhbFVybCBjYW4ndCBiZSByZW5kZXJlZCwgaXQncyBvbmx5IHVzZWQgdG8gY29udHJvbCB0aGUgaGlzdG9yeSB1cGRhdGVzIGluIHRoZSB1c2VFZmZlY3QgZnVydGhlciBkb3duIGluIHRoaXMgZmlsZS5cbiAgICBsb2NhdGlvblxuICAgICAgPyAvLyB3aW5kb3cubG9jYXRpb24gZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIFVSTCBidXQgaGFzIGFsbCB0aGUgZmllbGRzIGNyZWF0ZUhyZWZGcm9tVXJsIG5lZWRzLlxuICAgICAgICBjcmVhdGVIcmVmRnJvbVVybChsb2NhdGlvbilcbiAgICAgIDogaW5pdGlhbENhbm9uaWNhbFVybFxuXG4gIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMoaW5pdGlhbFRyZWUsIGNhbm9uaWNhbFVybClcblxuICBjb25zdCBwcmVmZXRjaENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4oKVxuXG4gIC8vIFdoZW4gdGhlIGNhY2hlIGhhc24ndCBiZWVuIHNlZWRlZCB5ZXQgd2UgZmlsbCB0aGUgY2FjaGUgd2l0aCB0aGUgaGVhZC5cbiAgaWYgKGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9PT0gbnVsbCB8fCBpbml0aWFsUGFyYWxsZWxSb3V0ZXMuc2l6ZSA9PT0gMCkge1xuICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgY2FjaGUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBpbml0aWFsVHJlZSxcbiAgICAgIGluaXRpYWxTZWVkRGF0YSxcbiAgICAgIGluaXRpYWxIZWFkLFxuICAgICAgdW5kZWZpbmVkXG4gICAgKVxuICB9XG5cbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIHRyZWU6IGluaXRpYWxUcmVlLFxuICAgIGNhY2hlLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAgcHVzaFJlZjoge1xuICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAvLyBGaXJzdCByZW5kZXIgbmVlZHMgdG8gcHJlc2VydmUgdGhlIHByZXZpb3VzIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgICAvLyB0byBhdm9pZCBpdCBiZWluZyBvdmVyd3JpdHRlbiBvbiBuYXZpZ2F0aW9uIGJhY2svZm9yd2FyZCB3aXRoIE1QQSBOYXZpZ2F0aW9uLlxuICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWUsXG4gICAgfSxcbiAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgYXBwbHk6IGZhbHNlLFxuICAgICAgb25seUhhc2hDaGFuZ2U6IGZhbHNlLFxuICAgICAgaGFzaEZyYWdtZW50OiBudWxsLFxuICAgICAgc2VnbWVudFBhdGhzOiBbXSxcbiAgICB9LFxuICAgIGNhbm9uaWNhbFVybCxcbiAgICBuZXh0VXJsOlxuICAgICAgLy8gdGhlIHx8IG9wZXJhdG9yIGlzIGludGVudGlvbmFsLCB0aGUgcGF0aG5hbWUgY2FuIGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgKGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKGluaXRpYWxUcmVlKSB8fCBsb2NhdGlvbj8ucGF0aG5hbWUpID8/XG4gICAgICBudWxsLFxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmIGxvY2F0aW9uKSB7XG4gICAgLy8gU2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGUgd2l0aCB0aGlzIHBhZ2UncyBkYXRhLlxuICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBuZWVkbGVzc2x5IHJlLXByZWZldGNoaW5nIGEgcGFnZSB0aGF0IGlzIGFscmVhZHkgcmV1c2FibGUsXG4gICAgLy8gYW5kIHdpbGwgYXZvaWQgdHJpZ2dlcmluZyBhIGxvYWRpbmcgc3RhdGUvZGF0YSBmZXRjaCBzdGFsbCB3aGVuIG5hdmlnYXRpbmcgYmFjayB0byB0aGUgcGFnZS5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgZG8gdGhpcyBpbiBkZXZlbG9wbWVudCBiZWNhdXNlIGxpbmtzIGFyZW4ndCBwcmVmZXRjaGVkIGluIGRldmVsb3BtZW50XG4gICAgLy8gc28gaGF2aW5nIGEgbWlzbWF0Y2ggYmV0d2VlbiBwcmVmZXRjaC9ubyBwcmVmZXRjaCBwcm92aWRlcyBpbmNvbnNpc3RlbnQgYmVoYXZpb3IgYmFzZWQgb24gd2hpY2ggcGFnZVxuICAgIC8vIHdhcyBsb2FkZWQgZmlyc3QuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGAke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofWAsXG4gICAgICBsb2NhdGlvbi5vcmlnaW5cbiAgICApXG5cbiAgICBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YToge1xuICAgICAgICBmbGlnaHREYXRhOiBbbm9ybWFsaXplZEZsaWdodERhdGFdLFxuICAgICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgY291bGRCZUludGVyY2VwdGVkOiAhIWNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgICAgICAgcHJlcmVuZGVyZWQsXG4gICAgICAgIHBvc3Rwb25lZCxcbiAgICAgICAgLy8gVE9ETzogVGhlIGluaXRpYWwgUlNDIHBheWxvYWQgaW5jbHVkZXMgYm90aCBzdGF0aWMgYW5kIGR5bmFtaWMgZGF0YVxuICAgICAgICAvLyBpbiB0aGUgc2FtZSByZXNwb25zZSwgZXZlbiBpZiBQUFIgaXMgZW5hYmxlZC4gU28gaWYgdGhlcmUncyBhbnlcbiAgICAgICAgLy8gZHluYW1pYyBkYXRhIGF0IGFsbCwgd2UgY2FuJ3Qgc2V0IGEgc3RhbGUgdGltZS4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXlcbiAgICAgICAgLy8gYWRkIGEgd2F5IHRvIHNwbGl0IGEgc2luZ2xlIEZsaWdodCBzdHJlYW0gaW50byBzdGF0aWMgYW5kIGR5bmFtaWNcbiAgICAgICAgLy8gcGFydHMuIEJ1dCBpbiB0aGUgbWVhbnRpbWUgd2Ugc2hvdWxkIGF0IGxlYXN0IG1ha2UgdGhpcyB3b3JrIGZvclxuICAgICAgICAvLyBmdWxseSBzdGF0aWMgcGFnZXMuXG4gICAgICAgIHN0YWxlVGltZTogLTEsXG4gICAgICB9LFxuICAgICAgdHJlZTogaW5pdGlhbFN0YXRlLnRyZWUsXG4gICAgICBwcmVmZXRjaENhY2hlOiBpbml0aWFsU3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgIG5leHRVcmw6IGluaXRpYWxTdGF0ZS5uZXh0VXJsLFxuICAgICAga2luZDogcHJlcmVuZGVyZWQgPyBQcmVmZXRjaEtpbmQuRlVMTCA6IFByZWZldGNoS2luZC5BVVRPLFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gaW5pdGlhbFN0YXRlXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIiwiaW5pdGlhbEZsaWdodERhdGEiLCJpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJsb2NhdGlvbiIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInBvc3Rwb25lZCIsInByZXJlbmRlcmVkIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImpvaW4iLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsImdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoIiwidHJlZSIsImluaXRpYWxUcmVlIiwic2VlZERhdGEiLCJpbml0aWFsU2VlZERhdGEiLCJoZWFkIiwiaW5pdGlhbEhlYWQiLCJyc2MiLCJsb2FkaW5nIiwiY2FjaGUiLCJsYXp5RGF0YSIsInByZWZldGNoUnNjIiwicHJlZmV0Y2hIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJjYW5vbmljYWxVcmwiLCJjcmVhdGVIcmVmRnJvbVVybCIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwic2l6ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwidW5kZWZpbmVkIiwiZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5Iiwib25seUhhc2hDaGFuZ2UiLCJoYXNoRnJhZ21lbnQiLCJzZWdtZW50UGF0aHMiLCJuZXh0VXJsIiwicGF0aG5hbWUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ1cmwiLCJVUkwiLCJzZWFyY2giLCJvcmlnaW4iLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJkYXRhIiwiZmxpZ2h0RGF0YSIsInN0YWxlVGltZSIsImtpbmQiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiQVVUTyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\nconst _setcachebustingsearchparam = __webpack_require__(/*! ./set-cache-busting-search-param */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\");\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromReadableStream } from 'react-server-dom-webpack/client'\nconst { createFromReadableStream } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction doMpaNavigation(url) {\n    return {\n        flightData: urlToUrlWithoutFlightMarker(url).toString(),\n        canonicalUrl: undefined,\n        couldBeIntercepted: false,\n        prerendered: false,\n        postponed: false,\n        staleTime: -1\n    };\n}\nlet abortController = new AbortController();\nif (true) {\n    // Abort any in-flight requests when the page is unloaded, e.g. due to\n    // reloading the page or performing hard navigations. This allows us to ignore\n    // what would otherwise be a thrown TypeError when the browser cancels the\n    // requests.\n    window.addEventListener('pagehide', ()=>{\n        abortController.abort();\n    });\n    // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n    // and the JavaScript execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        abortController = new AbortController();\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(flightRouterState))\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if ( true && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        var _res_headers_get;\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        if (false) {}\n        const res = await createFetch(url, headers, fetchPriority, abortController.signal);\n        const responseUrl = urlToUrlWithoutFlightMarker(res.url);\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeader = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeader !== null ? parseInt(staleTimeHeader, 10) : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        if (true) {\n            await (__webpack_require__(/*! ../react-dev-overlay/app/hot-reloader-client */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js\").waitForWebpackRuntimeHotUpdate)();\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n        const response = await createFromNextReadableStream(flightStream);\n        if ((0, _appbuildid.getAppBuildId)() !== response.b) {\n            return doMpaNavigation(res.url);\n        }\n        return {\n            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            canonicalUrl: canonicalUrl,\n            couldBeIntercepted: interception,\n            prerendered: response.S,\n            postponed,\n            staleTime\n        };\n    } catch (err) {\n        if (!abortController.signal.aborted) {\n            console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return {\n            flightData: url.toString(),\n            canonicalUrl: undefined,\n            couldBeIntercepted: false,\n            prerendered: false,\n            postponed: false,\n            staleTime: -1\n        };\n    }\n}\nfunction createFetch(url, headers, fetchPriority, signal) {\n    const fetchUrl = new URL(url);\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    if (false) {}\n    if (false) {}\n    return fetch(fetchUrl, {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    });\n}\nfunction createFromNextReadableStream(flightStream) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXVRZ0JBLFdBQVc7ZUFBWEE7O0lBOEJBQyw0QkFBNEI7ZUFBNUJBOztJQS9LTUMsbUJBQW1CO2VBQW5CQTs7SUFsRE5DLDJCQUEyQjtlQUEzQkE7Ozs4Q0F2Q1Q7MkNBQ29CO2lEQUNNO2dEQUNKOytDQUl0Qjt3Q0FDdUI7d0RBQ2E7QUFwQzNDLGFBQWE7QUFDYiw2REFBNkQ7QUFDN0QsNkVBQTZFO0FBQzdFLE1BQU0sRUFBRUMsd0JBQXdCLEVBQUUsR0FDaEMsTUFBMEIsR0FFdEJJLENBQStDLEdBRS9DQSxtQkFBT0EsQ0FBQyxpSUFBaUM7QUEwRHhDLFNBQVNMLDRCQUE0Qk0sR0FBVztJQUNyRCxNQUFNQyw2QkFBNkIsSUFBSUMsSUFBSUYsS0FBS0csU0FBU0MsTUFBTTtJQUMvREgsMkJBQTJCSSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0Msa0JBQUFBLG9CQUFvQjtJQUNuRSxJQUFJWCxLQUFvQixFQUFtQixFQVUxQztJQUNELE9BQU9LO0FBQ1Q7QUFFQSxTQUFTYSxnQkFBZ0JkLEdBQVc7SUFDbEMsT0FBTztRQUNMZSxZQUFZckIsNEJBQTRCTSxLQUFLZ0IsUUFBUTtRQUNyREMsY0FBY0M7UUFDZEMsb0JBQW9CO1FBQ3BCQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsV0FBVyxDQUFDO0lBQ2Q7QUFDRjtBQUVBLElBQUlDLGtCQUFrQixJQUFJQztBQUUxQixJQUFJLElBQTZCLEVBQUU7SUFDakMsc0VBQXNFO0lBQ3RFLDhFQUE4RTtJQUM5RSwwRUFBMEU7SUFDMUUsWUFBWTtJQUNaQyxPQUFPQyxnQkFBZ0IsQ0FBQyxZQUFZO1FBQ2xDSCxnQkFBZ0JJLEtBQUs7SUFDdkI7SUFFQSw4RUFBOEU7SUFDOUUsbUVBQW1FO0lBQ25FRixPQUFP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QUNGO0FBRUEsU0FBU25CLDhCQUNQb0Isb0JBQWdEO0lBRWhELDBFQUEwRTtJQUMxRSw0RUFBNEU7SUFDNUUsdUVBQXVFO0lBQ3ZFLDBFQUEwRTtJQUMxRSw4REFBOEQ7SUFDOUQsMkNBQTJDO0lBQzNDLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsMEVBQTBFO0lBQzFFLDhFQUE4RTtJQUM5RSwrQkFBK0I7SUFDL0IsTUFBTUMsU0FBU0QscUJBQXFCRSxTQUFTO0lBQzdDLE9BQU8sSUFBSUMsZUFBZTtRQUN4QixNQUFNQyxNQUFLQyxVQUFVO1lBQ25CLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT08sSUFBSTtnQkFDekMsSUFBSSxDQUFDRixNQUFNO29CQUNULG1FQUFtRTtvQkFDbkUsbUJBQW1CO29CQUNuQkQsV0FBV0ksT0FBTyxDQUFDRjtvQkFDbkI7Z0JBQ0Y7Z0JBQ0EscUVBQXFFO2dCQUNyRSxxQkFBcUI7Z0JBQ3JCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxmZXRjaC1zZXJ2ZXItcmVzcG9uc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIEB0cy1pZ25vcmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbi8vIGltcG9ydCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnXG5jb25zdCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSB9ID0gKFxuICAhIXByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRVxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuICAgICAgcmVxdWlyZSgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5lZGdlJylcbiAgICA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbiAgICAgIHJlcXVpcmUoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnKVxuKSBhcyB0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50JylcblxuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuaW1wb3J0IHR5cGUgeyBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUiB9IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB7XG4gIE5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfUlNDX1VOSU9OX1FVRVJZLFxuICBORVhUX1VSTCxcbiAgUlNDX0hFQURFUixcbiAgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG4gIE5FWFRfSE1SX1JFRlJFU0hfSEVBREVSLFxuICBORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSLFxufSBmcm9tICcuLi9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQgeyBjYWxsU2VydmVyIH0gZnJvbSAnLi4vLi4vYXBwLWNhbGwtc2VydmVyJ1xuaW1wb3J0IHsgZmluZFNvdXJjZU1hcFVSTCB9IGZyb20gJy4uLy4uL2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsJ1xuaW1wb3J0IHsgUHJlZmV0Y2hLaW5kIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHR5cGUgTm9ybWFsaXplZEZsaWdodERhdGEsXG59IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBnZXRBcHBCdWlsZElkIH0gZnJvbSAnLi4vLi4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHsgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gfSBmcm9tICcuL3NldC1jYWNoZS1idXN0aW5nLXNlYXJjaC1wYXJhbSdcblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaFNlcnZlclJlc3BvbnNlT3B0aW9ucyB7XG4gIHJlYWRvbmx5IGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICByZWFkb25seSBuZXh0VXJsOiBzdHJpbmcgfCBudWxsXG4gIHJlYWRvbmx5IHByZWZldGNoS2luZD86IFByZWZldGNoS2luZFxuICByZWFkb25seSBpc0htclJlZnJlc2g/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQgPSB7XG4gIGZsaWdodERhdGE6IE5vcm1hbGl6ZWRGbGlnaHREYXRhW10gfCBzdHJpbmdcbiAgY2Fub25pY2FsVXJsOiBVUkwgfCB1bmRlZmluZWRcbiAgY291bGRCZUludGVyY2VwdGVkOiBib29sZWFuXG4gIHByZXJlbmRlcmVkOiBib29sZWFuXG4gIHBvc3Rwb25lZDogYm9vbGVhblxuICBzdGFsZVRpbWU6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBSZXF1ZXN0SGVhZGVycyA9IHtcbiAgW1JTQ19IRUFERVJdPzogJzEnXG4gIFtORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl0/OiBzdHJpbmdcbiAgW05FWFRfVVJMXT86IHN0cmluZ1xuICBbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXT86ICcxJ1xuICBbTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVJdPzogc3RyaW5nXG4gICd4LWRlcGxveW1lbnQtaWQnPzogc3RyaW5nXG4gIFtORVhUX0hNUl9SRUZSRVNIX0hFQURFUl0/OiAnMSdcbiAgLy8gQSBoZWFkZXIgdGhhdCBpcyBvbmx5IGFkZGVkIGluIHRlc3QgbW9kZSB0byBhc3NlcnQgb24gZmV0Y2ggcHJpb3JpdHlcbiAgJ05leHQtVGVzdC1GZXRjaC1Qcmlvcml0eSc/OiBSZXF1ZXN0SW5pdFsncHJpb3JpdHknXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybDogc3RyaW5nKTogVVJMIHtcbiAgY29uc3QgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24ub3JpZ2luKVxuICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5zZWFyY2hQYXJhbXMuZGVsZXRlKE5FWFRfUlNDX1VOSU9OX1FVRVJZKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9DT05GSUdfT1VUUFVUID09PSAnZXhwb3J0JyAmJlxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUuZW5kc1dpdGgoJy50eHQnKVxuICAgICkge1xuICAgICAgY29uc3QgeyBwYXRobmFtZSB9ID0gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHBhdGhuYW1lLmVuZHNXaXRoKCcvaW5kZXgudHh0JykgPyAxMCA6IDRcbiAgICAgIC8vIFNsaWNlIG9mZiBgL2luZGV4LnR4dGAgb3IgYC50eHRgIGZyb20gdGhlIGVuZCBvZiB0aGUgcGF0aG5hbWVcbiAgICAgIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnBhdGhuYW1lID0gcGF0aG5hbWUuc2xpY2UoMCwgLWxlbmd0aClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzXG59XG5cbmZ1bmN0aW9uIGRvTXBhTmF2aWdhdGlvbih1cmw6IHN0cmluZyk6IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQge1xuICByZXR1cm4ge1xuICAgIGZsaWdodERhdGE6IHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcih1cmwpLnRvU3RyaW5nKCksXG4gICAgY2Fub25pY2FsVXJsOiB1bmRlZmluZWQsXG4gICAgY291bGRCZUludGVyY2VwdGVkOiBmYWxzZSxcbiAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgcG9zdHBvbmVkOiBmYWxzZSxcbiAgICBzdGFsZVRpbWU6IC0xLFxuICB9XG59XG5cbmxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEFib3J0IGFueSBpbi1mbGlnaHQgcmVxdWVzdHMgd2hlbiB0aGUgcGFnZSBpcyB1bmxvYWRlZCwgZS5nLiBkdWUgdG9cbiAgLy8gcmVsb2FkaW5nIHRoZSBwYWdlIG9yIHBlcmZvcm1pbmcgaGFyZCBuYXZpZ2F0aW9ucy4gVGhpcyBhbGxvd3MgdXMgdG8gaWdub3JlXG4gIC8vIHdoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGEgdGhyb3duIFR5cGVFcnJvciB3aGVuIHRoZSBicm93c2VyIGNhbmNlbHMgdGhlXG4gIC8vIHJlcXVlc3RzLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCAoKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgfSlcblxuICAvLyBVc2UgYSBmcmVzaCBBYm9ydENvbnRyb2xsZXIgaW5zdGFuY2Ugb24gcGFnZXNob3csIGUuZy4gd2hlbiBuYXZpZ2F0aW5nIGJhY2tcbiAgLy8gYW5kIHRoZSBKYXZhU2NyaXB0IGV4ZWN1dGlvbiBjb250ZXh0IGlzIHJlc3RvcmVkIGJ5IHRoZSBicm93c2VyLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCAoKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIH0pXG59XG5cbi8qKlxuICogRmV0Y2ggdGhlIGZsaWdodCBkYXRhIGZvciB0aGUgcHJvdmlkZWQgdXJsLiBUYWtlcyBpbiB0aGUgY3VycmVudCByb3V0ZXIgc3RhdGVcbiAqIHRvIGRlY2lkZSB3aGF0IHRvIHJlbmRlciBzZXJ2ZXItc2lkZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmVyUmVzcG9uc2UoXG4gIHVybDogVVJMLFxuICBvcHRpb25zOiBGZXRjaFNlcnZlclJlc3BvbnNlT3B0aW9uc1xuKTogUHJvbWlzZTxGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0PiB7XG4gIGNvbnN0IHsgZmxpZ2h0Um91dGVyU3RhdGUsIG5leHRVcmwsIHByZWZldGNoS2luZCB9ID0gb3B0aW9uc1xuXG4gIGNvbnN0IGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzID0ge1xuICAgIC8vIEVuYWJsZSBmbGlnaHQgcmVzcG9uc2VcbiAgICBbUlNDX0hFQURFUl06ICcxJyxcbiAgICAvLyBQcm92aWRlIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICAgIFtORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl06IGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIEpTT04uc3RyaW5naWZ5KGZsaWdodFJvdXRlclN0YXRlKVxuICAgICksXG4gIH1cblxuICAvKipcbiAgICogVGhyZWUgY2FzZXM6XG4gICAqIC0gYHByZWZldGNoS2luZGAgaXMgYHVuZGVmaW5lZGAsIGl0IG1lYW5zIGl0J3MgYSBub3JtYWwgbmF2aWdhdGlvbiwgc28gd2Ugd2FudCB0byBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5XG4gICAqIC0gYHByZWZldGNoS2luZGAgaXMgYGZ1bGxgIC0gd2Ugd2FudCB0byBwcmVmZXRjaCB0aGUgd2hvbGUgcGFnZSBzbyBzYW1lIGFzIGFib3ZlXG4gICAqIC0gYHByZWZldGNoS2luZGAgaXMgYGF1dG9gIC0gaWYgdGhlIHBhZ2UgaXMgZHluYW1pYywgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBwYXJ0aWFsbHksIGlmIHN0YXRpYyBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5XG4gICAqL1xuICBpZiAocHJlZmV0Y2hLaW5kID09PSBQcmVmZXRjaEtpbmQuQVVUTykge1xuICAgIGhlYWRlcnNbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXSA9ICcxJ1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIG9wdGlvbnMuaXNIbXJSZWZyZXNoKSB7XG4gICAgaGVhZGVyc1tORVhUX0hNUl9SRUZSRVNIX0hFQURFUl0gPSAnMSdcbiAgfVxuXG4gIGlmIChuZXh0VXJsKSB7XG4gICAgaGVhZGVyc1tORVhUX1VSTF0gPSBuZXh0VXJsXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdoZW4gY3JlYXRpbmcgYSBcInRlbXBvcmFyeVwiIHByZWZldGNoICh0aGUgXCJvbi1kZW1hbmRcIiBwcmVmZXRjaCB0aGF0IGdldHMgY3JlYXRlZCBvbiBuYXZpZ2F0aW9uLCBpZiBvbmUgZG9lc24ndCBleGlzdClcbiAgICAvLyB3ZSBzZW5kIHRoZSByZXF1ZXN0IHdpdGggYSBcImhpZ2hcIiBwcmlvcml0eSBhcyBpdCdzIGluIHJlc3BvbnNlIHRvIGEgdXNlciBpbnRlcmFjdGlvbiB0aGF0IGNvdWxkIGJlIGJsb2NraW5nIGEgdHJhbnNpdGlvbi5cbiAgICAvLyBPdGhlcndpc2UsIGFsbCBvdGhlciBwcmVmZXRjaGVzIGFyZSBzZW50IHdpdGggYSBcImxvd1wiIHByaW9yaXR5LlxuICAgIC8vIFdlIHVzZSBcImF1dG9cIiBmb3IgaW4gYWxsIG90aGVyIGNhc2VzIHRvIG1hdGNoIHRoZSBleGlzdGluZyBkZWZhdWx0LCBhcyB0aGlzIGZ1bmN0aW9uIGlzIHNoYXJlZCBvdXRzaWRlIG9mIHByZWZldGNoaW5nLlxuICAgIGNvbnN0IGZldGNoUHJpb3JpdHkgPSBwcmVmZXRjaEtpbmRcbiAgICAgID8gcHJlZmV0Y2hLaW5kID09PSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZXG4gICAgICAgID8gJ2hpZ2gnXG4gICAgICAgIDogJ2xvdydcbiAgICAgIDogJ2F1dG8nXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DT05GSUdfT1VUUFVUID09PSAnZXhwb3J0Jykge1xuICAgICAgICAvLyBJbiBcIm91dHB1dDogZXhwb3J0XCIgbW9kZSwgd2UgY2FuJ3QgcmVseSBvbiBoZWFkZXJzIHRvIGRpc3Rpbmd1aXNoXG4gICAgICAgIC8vIGJldHdlZW4gSFRNTCBhbmQgUlNDIHJlcXVlc3RzLiBJbnN0ZWFkLCB3ZSBhcHBlbmQgYW4gZXh0cmEgcHJlZml4XG4gICAgICAgIC8vIHRvIHRoZSByZXF1ZXN0LlxuICAgICAgICB1cmwgPSBuZXcgVVJMKHVybClcbiAgICAgICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgdXJsLnBhdGhuYW1lICs9ICdpbmRleC50eHQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsLnBhdGhuYW1lICs9ICcudHh0J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3JlYXRlRmV0Y2goXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgZmV0Y2hQcmlvcml0eSxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApXG5cbiAgICBjb25zdCByZXNwb25zZVVybCA9IHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihyZXMudXJsKVxuICAgIGNvbnN0IGNhbm9uaWNhbFVybCA9IHJlcy5yZWRpcmVjdGVkID8gcmVzcG9uc2VVcmwgOiB1bmRlZmluZWRcblxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJ1xuICAgIGNvbnN0IGludGVyY2VwdGlvbiA9ICEhcmVzLmhlYWRlcnMuZ2V0KCd2YXJ5Jyk/LmluY2x1ZGVzKE5FWFRfVVJMKVxuICAgIGNvbnN0IHBvc3Rwb25lZCA9ICEhcmVzLmhlYWRlcnMuZ2V0KE5FWFRfRElEX1BPU1RQT05FX0hFQURFUilcbiAgICBjb25zdCBzdGFsZVRpbWVIZWFkZXIgPSByZXMuaGVhZGVycy5nZXQoTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIpXG4gICAgY29uc3Qgc3RhbGVUaW1lID1cbiAgICAgIHN0YWxlVGltZUhlYWRlciAhPT0gbnVsbCA/IHBhcnNlSW50KHN0YWxlVGltZUhlYWRlciwgMTApIDogLTFcbiAgICBsZXQgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIpXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DT05GSUdfT1VUUFVUID09PSAnZXhwb3J0Jykge1xuICAgICAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UpIHtcbiAgICAgICAgICBpc0ZsaWdodFJlc3BvbnNlID0gY29udGVudFR5cGUuc3RhcnRzV2l0aCgndGV4dC9wbGFpbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBmZXRjaCByZXR1cm5zIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBmbGlnaHQgcmVzcG9uc2UgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIC8vIElmIHRoZSBmZXRjaCB3YXMgbm90IDIwMCwgd2UgYWxzbyBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlIHx8ICFyZXMub2sgfHwgIXJlcy5ib2R5KSB7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcmlnaW5hbCBVUkwgY2FtZSB3aXRoIGEgaGFzaCwgcHJlc2VydmUgaXQgYmVmb3JlIHJlZGlyZWN0aW5nIHRvIHRoZSBuZXcgVVJMXG4gICAgICBpZiAodXJsLmhhc2gpIHtcbiAgICAgICAgcmVzcG9uc2VVcmwuaGFzaCA9IHVybC5oYXNoXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkb01wYU5hdmlnYXRpb24ocmVzcG9uc2VVcmwudG9TdHJpbmcoKSlcbiAgICB9XG5cbiAgICAvLyBXZSBtYXkgbmF2aWdhdGUgdG8gYSBwYWdlIHRoYXQgcmVxdWlyZXMgYSBkaWZmZXJlbnQgV2VicGFjayBydW50aW1lLlxuICAgIC8vIEluIHByb2QsIGV2ZXJ5IHBhZ2Ugd2lsbCBoYXZlIHRoZSBzYW1lIFdlYnBhY2sgcnVudGltZS5cbiAgICAvLyBJbiBkZXYsIHRoZSBXZWJwYWNrIHJ1bnRpbWUgaXMgbWluaW1hbCBmb3IgZWFjaCBwYWdlLlxuICAgIC8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoZSBXZWJwYWNrIHJ1bnRpbWUgaXMgdXBkYXRlZCBiZWZvcmUgZXhlY3V0aW5nIGNsaWVudC1zaWRlIEpTIG9mIHRoZSBuZXcgcGFnZS5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhcHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICBhd2FpdCByZXF1aXJlKCcuLi9yZWFjdC1kZXYtb3ZlcmxheS9hcHAvaG90LXJlbG9hZGVyLWNsaWVudCcpLndhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBgZmV0Y2hgIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1bndyYXBwZWQgYnkgYFJlYWN0LnVzZWAuXG4gICAgY29uc3QgZmxpZ2h0U3RyZWFtID0gcG9zdHBvbmVkXG4gICAgICA/IGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKHJlcy5ib2R5KVxuICAgICAgOiByZXMuYm9keVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gICAgICBmbGlnaHRTdHJlYW1cbiAgICApIGFzIFByb21pc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPilcblxuICAgIGlmIChnZXRBcHBCdWlsZElkKCkgIT09IHJlc3BvbnNlLmIpIHtcbiAgICAgIHJldHVybiBkb01wYU5hdmlnYXRpb24ocmVzLnVybClcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogbm9ybWFsaXplRmxpZ2h0RGF0YShyZXNwb25zZS5mKSxcbiAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsLFxuICAgICAgY291bGRCZUludGVyY2VwdGVkOiBpbnRlcmNlcHRpb24sXG4gICAgICBwcmVyZW5kZXJlZDogcmVzcG9uc2UuUyxcbiAgICAgIHBvc3Rwb25lZCxcbiAgICAgIHN0YWxlVGltZSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoIFJTQyBwYXlsb2FkIGZvciAke3VybH0uIEZhbGxpbmcgYmFjayB0byBicm93c2VyIG5hdmlnYXRpb24uYCxcbiAgICAgICAgZXJyXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggZmFpbHMgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIC8vIFRPRE8tQVBQOiBBZGQgYSB0ZXN0IGZvciB0aGUgY2FzZSB3aGVyZSBhIENPUlMgcmVxdWVzdCBmYWlscywgZS5nLiBleHRlcm5hbCB1cmwgcmVkaXJlY3QgY29taW5nIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQzNjA1I2lzc3VlY29tbWVudC0xNDUxNjE3NTIxIGZvciBhIHJlcHJvZHVjdGlvbi5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogdXJsLnRvU3RyaW5nKCksXG4gICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgICAgc3RhbGVUaW1lOiAtMSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZldGNoKFxuICB1cmw6IFVSTCxcbiAgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMsXG4gIGZldGNoUHJpb3JpdHk6ICdhdXRvJyB8ICdoaWdoJyB8ICdsb3cnIHwgbnVsbCxcbiAgc2lnbmFsPzogQWJvcnRTaWduYWxcbikge1xuICBjb25zdCBmZXRjaFVybCA9IG5ldyBVUkwodXJsKVxuXG4gIC8vIFRPRE86IEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB0aGUgaGVhZGVycyBkbyBub3RoaW5nLiBPbWl0IHRoZW0gKGFuZCB0aGVcbiAgLy8gY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0pIGZyb20gdGhlIHJlcXVlc3Qgc28gdGhleSdyZVxuICAvLyBtYXhpbWFsbHkgY2FjaGVhYmxlLlxuICBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbShmZXRjaFVybCwgaGVhZGVycylcblxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSAmJiBmZXRjaFByaW9yaXR5ICE9PSBudWxsKSB7XG4gICAgaGVhZGVyc1snTmV4dC1UZXN0LUZldGNoLVByaW9yaXR5J10gPSBmZXRjaFByaW9yaXR5XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEKSB7XG4gICAgaGVhZGVyc1sneC1kZXBsb3ltZW50LWlkJ10gPSBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgfVxuXG4gIHJldHVybiBmZXRjaChmZXRjaFVybCwge1xuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIG9sZGVyIGJyb3dzZXJzLiBgc2FtZS1vcmlnaW5gIGlzIHRoZSBkZWZhdWx0IGluIG1vZGVybiBicm93c2Vycy5cbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBoZWFkZXJzLFxuICAgIHByaW9yaXR5OiBmZXRjaFByaW9yaXR5IHx8IHVuZGVmaW5lZCxcbiAgICBzaWduYWwsXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtKFxuICBmbGlnaHRTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgcmV0dXJuIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbShmbGlnaHRTdHJlYW0sIHtcbiAgICBjYWxsU2VydmVyLFxuICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKFxuICBvcmlnaW5hbEZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgLy8gV2hlbiBQUFIgaXMgZW5hYmxlZCwgcHJlZmV0Y2ggc3RyZWFtcyBtYXkgY29udGFpbiByZWZlcmVuY2VzIHRoYXQgbmV2ZXJcbiAgLy8gcmVzb2x2ZSwgYmVjYXVzZSB0aGF0J3MgaG93IHdlIGVuY29kZSBkeW5hbWljIGRhdGEgYWNjZXNzLiBJbiB0aGUgZGVjb2RlZFxuICAvLyBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIEZsaWdodCBjbGllbnQsIHRoZXNlIGFyZSByZWlmaWVkIGludG8gaGFuZ2luZ1xuICAvLyBwcm9taXNlcyB0aGF0IHN1c3BlbmQgZHVyaW5nIHJlbmRlciwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgd2hhdCB3ZSB3YW50LlxuICAvLyBUaGUgVUkgcmVzb2x2ZXMgd2hlbiBpdCBzd2l0Y2hlcyB0byB0aGUgZHluYW1pYyBkYXRhIHN0cmVhbVxuICAvLyAodmlhIHVzZURlZmVycmVkVmFsdWUoZHluYW1pYywgc3RhdGljKSkuXG4gIC8vXG4gIC8vIEhvd2V2ZXIsIHRoZSBGbGlnaHQgaW1wbGVtZW50YXRpb24gY3VycmVudGx5IGVycm9ycyBpZiB0aGUgc2VydmVyIGNsb3Nlc1xuICAvLyB0aGUgcmVzcG9uc2UgYmVmb3JlIGFsbCB0aGUgcmVmZXJlbmNlcyBhcmUgcmVzb2x2ZWQuIEFzIGEgY2hlYXQgdG8gd29ya1xuICAvLyBhcm91bmQgdGhpcywgd2Ugd3JhcCB0aGUgb3JpZ2luYWwgc3RyZWFtIGluIGEgbmV3IHN0cmVhbSB0aGF0IG5ldmVyIGNsb3NlcyxcbiAgLy8gYW5kIHRoZXJlZm9yZSBkb2Vzbid0IGVycm9yLlxuICBjb25zdCByZWFkZXIgPSBvcmlnaW5hbEZsaWdodFN0cmVhbS5nZXRSZWFkZXIoKVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgLy8gUGFzcyB0byB0aGUgdGFyZ2V0IHN0cmVhbSBhbmQga2VlcCBjb25zdW1pbmcgdGhlIEZsaWdodCByZXNwb25zZVxuICAgICAgICAgIC8vIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc2VydmVyIHN0cmVhbSBoYXMgY2xvc2VkLiBFeGl0LCBidXQgaW50ZW50aW9uYWxseSBkbyBub3QgY2xvc2VcbiAgICAgICAgLy8gdGhlIHRhcmdldCBzdHJlYW0uXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlRmV0Y2giLCJjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsInVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJyZXF1aXJlIiwidXJsIiwidXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwiTk9ERV9FTlYiLCJfX05FWFRfQ09ORklHX09VVFBVVCIsInBhdGhuYW1lIiwiZW5kc1dpdGgiLCJsZW5ndGgiLCJzbGljZSIsImRvTXBhTmF2aWdhdGlvbiIsImZsaWdodERhdGEiLCJ0b1N0cmluZyIsImNhbm9uaWNhbFVybCIsInVuZGVmaW5lZCIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInByZXJlbmRlcmVkIiwicG9zdHBvbmVkIiwic3RhbGVUaW1lIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0Iiwib3B0aW9ucyIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInByZWZldGNoS2luZCIsImhlYWRlcnMiLCJSU0NfSEVBREVSIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIk5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUiIsImlzSG1yUmVmcmVzaCIsIk5FWFRfSE1SX1JFRlJFU0hfSEVBREVSIiwiTkVYVF9VUkwiLCJyZXMiLCJmZXRjaFByaW9yaXR5IiwiVEVNUE9SQVJZIiwic2lnbmFsIiwicmVzcG9uc2VVcmwiLCJyZWRpcmVjdGVkIiwiY29udGVudFR5cGUiLCJnZXQiLCJpbnRlcmNlcHRpb24iLCJpbmNsdWRlcyIsIk5FWFRfRElEX1BPU1RQT05FX0hFQURFUiIsInN0YWxlVGltZUhlYWRlciIsIk5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSIiwicGFyc2VJbnQiLCJpc0ZsaWdodFJlc3BvbnNlIiwic3RhcnRzV2l0aCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwib2siLCJib2R5IiwiaGFzaCIsIlRVUkJPUEFDSyIsIndhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSIsImZsaWdodFN0cmVhbSIsImNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtIiwicmVzcG9uc2UiLCJnZXRBcHBCdWlsZElkIiwiYiIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwiUyIsImVyciIsImFib3J0ZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJmZXRjaFVybCIsInNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwiX19ORVhUX1RFU1RfTU9ERSIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJwcmlvcml0eSIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImVucXVldWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime, staleTime } = param;\n    if (staleTime !== -1) {\n        // `staleTime` is the value sent by the server during static generation.\n        // When this is available, it takes precedence over any of the heuristics\n        // that follow.\n        //\n        // TODO: When PPR is enabled, the server will *always* return a stale time\n        // when prefetching. We should never use a prefetch entry that hasn't yet\n        // received data from the server. So the only two cases should be 1) we use\n        // the server-generated stale time 2) the unresolved entry is discarded.\n        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;\n    }\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHJlZmV0Y2gtY2FjaGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBK1lhQSxtQkFBbUI7ZUFBbkJBOztJQW5JR0MsOEJBQThCO2VBQTlCQTs7SUE5R0FDLDZCQUE2QjtlQUE3QkE7O0lBK05BQyxrQkFBa0I7ZUFBbEJBOzs7aURBMVhUO2dEQU1BOzZDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNsQixJQUFJQyxrQkFBa0JILElBQUlJLFFBQVE7SUFFbEMsNEZBQTRGO0lBQzVGLDhEQUE4RDtJQUM5RCxxRkFBcUY7SUFDckYsZ0ZBQWdGO0lBQ2hGLHFEQUFxRDtJQUNyRCxJQUFJSCxxQkFBcUI7UUFDdkIsMEVBQTBFO1FBQzFFLGtGQUFrRjtRQUNsRiw0Q0FBNEM7UUFDNUNFLG1CQUFtQkgsSUFBSUssTUFBTTtJQUMvQjtJQUVBLElBQUlILFFBQVE7UUFDVixPQUFRLEtBQUVBLFNBQVNKLGdDQUFnQ0s7SUFDckQ7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0csdUJBQ1BOLEdBQVEsRUFDUk8sSUFBOEIsRUFDOUJDLE9BQXVCO0lBRXZCLE9BQU9ULDJCQUEyQkMsS0FBS08sU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFRjtBQUNyRTtBQUVBLFNBQVNHLHNCQUNQWCxHQUFRLEVBQ1JPLElBQTJDLEVBQzNDQyxPQUFzQixFQUN0QkksYUFBOEMsRUFDOUNDLGFBQXNCO0lBSHRCTixJQUFBQSxTQUFBQSxLQUFBQSxHQUFBQSxPQUFxQkUsb0JBQUFBLFlBQVksQ0FBQ0ssU0FBUztJQUszQyw4RUFBOEU7SUFD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QUM1RSxzREFBc0Q7SUFDdEQsSUFBSTFELFNBQVNFLG9CQUFBQSxZQUFZLENBQUN3RSxJQUFJLEVBQUU7UUFDOUIsSUFBSXJCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZWpFLHFCQUFxQjtZQUNuRCxPQUFPc0Usb0JBQUFBLHdCQUF3QixDQUFDZSxLQUFLO1FBQ3ZDO0lBQ0Y7SUFFQSxpR0FBaUc7SUFDakcsSUFBSXhFLFNBQVNFLG9CQUFBQSxZQUFZLENBQUNDLElBQUksRUFBRTtRQUM5QixJQUFJa0QsS0FBS0MsR0FBRyxLQUFLRixlQUFlakUscUJBQXFCO1lBQ25ELE9BQU9zRSxvQkFBQUEsd0JBQXdCLENBQUNnQixRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPaEIsb0JBQUFBLHdCQUF3QixDQUFDVSxPQUFPO0FBQ3pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccHJlZmV0Y2gtY2FjaGUtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZmV0Y2hTZXJ2ZXJSZXNwb25zZSxcbiAgdHlwZSBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0LFxufSBmcm9tICcuL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7XG4gIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyxcbiAgdHlwZSBQcmVmZXRjaENhY2hlRW50cnksXG4gIFByZWZldGNoS2luZCxcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IHByZWZldGNoUXVldWUgfSBmcm9tICcuL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXInXG5cbmNvbnN0IElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSID0gJyUnXG5cbmV4cG9ydCB0eXBlIEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgPSBQcmVmZXRjaENhY2hlRW50cnkgJiB7XG4gIC8qKiBUaGlzIGlzIGEgc3BlY2lhbCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyBhIHByZWZldGNoIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCBhIGRpZmZlcmVudCBVUkxcbiAgICogd2FzIHJldHVybmVkIHJhdGhlciB0aGFuIHRoZSByZXF1ZXN0ZWQgVVJMLiBUaGlzIHNpZ25hbHMgdG8gdGhlIHJvdXRlciB0aGF0IGl0IHNob3VsZCBvbmx5XG4gICAqIGFwcGx5IHRoZSBwYXJ0IHRoYXQgZG9lc24ndCBkZXBlbmQgb24gc2VhcmNoUGFyYW1zIChzcGVjaWZpY2FsbHkgdGhlIGxvYWRpbmcgc3RhdGUpLlxuICAgKi9cbiAgYWxpYXNlZD86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2FjaGUga2V5IGZvciB0aGUgcm91dGVyIHByZWZldGNoIGNhY2hlXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYmVpbmcgbmF2aWdhdGVkIHRvXG4gKiBAcGFyYW0gbmV4dFVybCAtIGFuIGludGVybmFsIFVSTCwgcHJpbWFyaWx5IHVzZWQgZm9yIGhhbmRsaW5nIHJld3JpdGVzLiBEZWZhdWx0cyB0byAnLycuXG4gKiBAcmV0dXJuIFRoZSBnZW5lcmF0ZWQgcHJlZmV0Y2ggY2FjaGUga2V5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgdXJsOiBVUkwsXG4gIGluY2x1ZGVTZWFyY2hQYXJhbXM6IGJvb2xlYW4sXG4gIHByZWZpeD86IHN0cmluZyB8IG51bGxcbikge1xuICAvLyBJbml0aWFsbHkgd2Ugb25seSB1c2UgdGhlIHBhdGhuYW1lIGFzIHRoZSBjYWNoZSBrZXkuIFdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZVxuICAvLyBzZWFyY2ggcGFyYW1zIHNvIHRoYXQgbXVsdGlwbGUgVVJMcyB3aXRoIHRoZSBzYW1lIHNlYXJjaCBwYXJhbWV0ZXIgY2FuIHJlLXVzZVxuICAvLyBsb2FkaW5nIHN0YXRlcy5cbiAgbGV0IHBhdGhuYW1lRnJvbVVybCA9IHVybC5wYXRobmFtZVxuXG4gIC8vIFJTQyByZXNwb25zZXMgY2FuIGRpZmZlciBiYXNlZCBvbiBzZWFyY2ggcGFyYW1zLCBzcGVjaWZpY2FsbHkgaW4gdGhlIGNhc2Ugd2hlcmUgd2UgYXJlbid0XG4gIC8vIHJldHVybmluZyBhIHBhcnRpYWwgcmVzcG9uc2UgKGllIHdpdGggYFByZWZldGNoS2luZC5BVVRPYCkuXG4gIC8vIEluIHRoZSBhdXRvIGNhc2UsIHNpbmNlIGxvYWRpbmcuanMgJiBsYXlvdXQuanMgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gc2VhcmNoIHBhcmFtcyxcbiAgLy8gd2UgY2FuIHNhZmVseSByZS11c2UgdGhhdCBjYWNoZSBlbnRyeS4gQnV0IGZvciBmdWxsIHByZWZldGNoZXMsIHdlIHNob3VsZCBub3RcbiAgLy8gcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBhcyB0aGUgcmVzcG9uc2UgbWF5IGRpZmZlci5cbiAgaWYgKGluY2x1ZGVTZWFyY2hQYXJhbXMpIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIGluY2x1ZGUgdGhlIHNlYXJjaCBwYXJhbSBpbiB0aGUga2V5LFxuICAgIC8vIGFzIHdlJ2xsIGJlIGdldHRpbmcgYmFjayBhIGZ1bGwgcmVzcG9uc2UuIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSByZWFkIHRoZSBzZWFyY2hcbiAgICAvLyBwYXJhbXMgd2hlbiBnZW5lcmF0aW5nIHRoZSBmdWxsIHJlc3BvbnNlLlxuICAgIHBhdGhuYW1lRnJvbVVybCArPSB1cmwuc2VhcmNoXG4gIH1cblxuICBpZiAocHJlZml4KSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke0lOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSfSR7cGF0aG5hbWVGcm9tVXJsfWBcbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZUZyb21Vcmxcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCB8IHVuZGVmaW5lZCxcbiAgbmV4dFVybD86IHN0cmluZyB8IG51bGxcbikge1xuICByZXR1cm4gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwodXJsLCBraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCwgbmV4dFVybClcbn1cblxuZnVuY3Rpb24gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICB1cmw6IFVSTCxcbiAga2luZDogUHJlZmV0Y2hLaW5kID0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgcHJlZmV0Y2hDYWNoZTogTWFwPHN0cmluZywgUHJlZmV0Y2hDYWNoZUVudHJ5PixcbiAgYWxsb3dBbGlhc2luZzogYm9vbGVhblxuKTogQWxpYXNlZFByZWZldGNoQ2FjaGVFbnRyeSB8IHVuZGVmaW5lZCB7XG4gIC8vIFdlIGZpcnN0IGNoZWNrIGlmIHRoZXJlJ3MgYSBtb3JlIHNwZWNpZmljIGludGVyY2VwdGlvbiByb3V0ZSBwcmVmZXRjaCBlbnRyeVxuICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2hlbiB3ZSBkZXRlY3QgYSBwcmVmZXRjaCB0aGF0IGNvcnJlc3BvbmRzIHdpdGggYW4gaW50ZXJjZXB0aW9uIHJvdXRlLCB3ZSBwcmVmaXggaXQgd2l0aCBuZXh0VXJsIChzZWUgYGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlgKVxuICAvLyB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBvdGhlciBwYWdlcyB0aGF0IG1heSBoYXZlIHRoZSBzYW1lIFVSTCBidXQgcmVuZGVyIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBgTmV4dC1VUkxgIGhlYWRlci5cbiAgZm9yIChjb25zdCBtYXliZU5leHRVcmwgb2YgW25leHRVcmwsIG51bGxdKSB7XG4gICAgY29uc3QgY2FjaGVLZXlXaXRoUGFyYW1zID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gICAgICB1cmwsXG4gICAgICB0cnVlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuICAgIGNvbnN0IGNhY2hlS2V5V2l0aG91dFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgZmFsc2UsXG4gICAgICBtYXliZU5leHRVcmxcbiAgICApXG5cbiAgICAvLyBGaXJzdCwgd2UgY2hlY2sgaWYgd2UgaGF2ZSBhIGNhY2hlIGVudHJ5IHRoYXQgZXhhY3RseSBtYXRjaGVzIHRoZSBVUkxcbiAgICBjb25zdCBjYWNoZUtleVRvVXNlID0gdXJsLnNlYXJjaFxuICAgICAgPyBjYWNoZUtleVdpdGhQYXJhbXNcbiAgICAgIDogY2FjaGVLZXlXaXRob3V0UGFyYW1zXG5cbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlUb1VzZSlcbiAgICBpZiAoZXhpc3RpbmdFbnRyeSAmJiBhbGxvd0FsaWFzaW5nKSB7XG4gICAgICAvLyBXZSBrbm93IHdlJ3JlIHJldHVybmluZyBhbiBhbGlhc2VkIGVudHJ5IHdoZW4gdGhlIHBhdGhuYW1lIG1hdGNoZXMgYnV0IHRoZSBzZWFyY2ggcGFyYW1zIGRvbid0LFxuICAgICAgY29uc3QgaXNBbGlhc2VkID1cbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwucGF0aG5hbWUgPT09IHVybC5wYXRobmFtZSAmJlxuICAgICAgICBleGlzdGluZ0VudHJ5LnVybC5zZWFyY2ggIT09IHVybC5zZWFyY2hcblxuICAgICAgaWYgKGlzQWxpYXNlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nRW50cnksXG4gICAgICAgICAgYWxpYXNlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXF1ZXN0IGNvbnRhaW5zIHNlYXJjaCBwYXJhbXMsIGFuZCB3ZSdyZSBub3QgZG9pbmcgYSBmdWxsIHByZWZldGNoLCB3ZSBjYW4gcmV0dXJuIHRoZVxuICAgIC8vIHBhcmFtLWxlc3MgZW50cnkgaWYgaXQgZXhpc3RzLlxuICAgIC8vIFRoaXMgaXMgdGVjaG5pY2FsbHkgY292ZXJlZCBieSB0aGUgY2hlY2sgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZ1bmN0aW9uLCB3aGljaCBpdGVyYXRlcyBvdmVyIGNhY2hlIGVudHJpZXMsXG4gICAgLy8gYnV0IGxldHMgdXMgYXJyaXZlIHRoZXJlIHF1aWNrZXIgaW4gdGhlIHBhcmFtLWZ1bGwgY2FzZS5cbiAgICBjb25zdCBlbnRyeVdpdGhvdXRQYXJhbXMgPSBwcmVmZXRjaENhY2hlLmdldChjYWNoZUtleVdpdGhvdXRQYXJhbXMpXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIGFsbG93QWxpYXNpbmcgJiZcbiAgICAgIHVybC5zZWFyY2ggJiZcbiAgICAgIGtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgICBlbnRyeVdpdGhvdXRQYXJhbXMgJiZcbiAgICAgIC8vIFdlIHNob3VsZG4ndCByZXR1cm4gdGhlIGFsaWFzZWQgZW50cnkgaWYgaXQgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBjYWNoZSBrZXkuXG4gICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICFlbnRyeVdpdGhvdXRQYXJhbXMua2V5LmluY2x1ZGVzKElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSKVxuICAgICkge1xuICAgICAgcmV0dXJuIHsgLi4uZW50cnlXaXRob3V0UGFyYW1zLCBhbGlhc2VkOiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgd2UgZGlkbid0IGZpbmQgYSBzcGVjaWZpYyBjYWNoZSBlbnRyeSB0aGF0IG1hdGNoZWRcbiAgLy8gdGhlIHJlcXVlc3QgVVJMLlxuICAvLyBXZSBhdHRlbXB0IGEgcGFydGlhbCBtYXRjaCBieSBjaGVja2luZyBpZiB0aGVyZSdzIGEgY2FjaGUgZW50cnkgd2l0aCB0aGUgc2FtZSBwYXRobmFtZS5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGF0IHdlIGZpbmQsIHNpbmNlIGl0IGRvZXNuJ3QgY29ycmVzcG9uZCB3aXRoIHRoZSByZXF1ZXN0ZWQgVVJMLCB3ZSdsbCBtYXJrIGl0IFwiYWxpYXNlZFwiLlxuICAvLyBUaGlzIHdpbGwgc2lnbmFsIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seSBhcHBseSB0aGUgbG9hZGluZyBzdGF0ZSBvbiB0aGUgcHJlZmV0Y2hlZCBkYXRhLlxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgIGFsbG93QWxpYXNpbmdcbiAgKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZUVudHJ5IG9mIHByZWZldGNoQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgY2FjaGVFbnRyeS51cmwucGF0aG5hbWUgPT09IHVybC5wYXRobmFtZSAmJlxuICAgICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgIWNhY2hlRW50cnkua2V5LmluY2x1ZGVzKElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7IC4uLmNhY2hlRW50cnksIGFsaWFzZWQ6IHRydWUgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZmV0Y2ggY2FjaGUgZW50cnkgaWYgb25lIGV4aXN0cy4gT3RoZXJ3aXNlIGNyZWF0ZXMgYSBuZXcgb25lIGFuZCBlbnF1ZXVlcyBhIGZldGNoIHJlcXVlc3RcbiAqIHRvIHJldHJpZXZlIHRoZSBwcmVmZXRjaCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgdXJsLFxuICBuZXh0VXJsLFxuICB0cmVlLFxuICBwcmVmZXRjaENhY2hlLFxuICBraW5kLFxuICBhbGxvd0FsaWFzaW5nID0gdHJ1ZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICdwcmVmZXRjaENhY2hlJyB8ICd0cmVlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ/OiBQcmVmZXRjaEtpbmRcbiAgYWxsb3dBbGlhc2luZzogYm9vbGVhblxufSk6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkge1xuICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBnZXRFeGlzdGluZ0NhY2hlRW50cnkoXG4gICAgdXJsLFxuICAgIGtpbmQsXG4gICAgbmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlLFxuICAgIGFsbG93QWxpYXNpbmdcbiAgKVxuXG4gIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBHcmFiIHRoZSBsYXRlc3Qgc3RhdHVzIG9mIHRoZSBjYWNoZSBlbnRyeSBhbmQgdXBkYXRlIGl0XG4gICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YXR1cyA9IGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhleGlzdGluZ0NhY2hlRW50cnkpXG5cbiAgICAvLyB3aGVuIGBraW5kYCBpcyBwcm92aWRlZCwgYW4gZXhwbGljaXQgcHJlZmV0Y2ggd2FzIHJlcXVlc3RlZC5cbiAgICAvLyBpZiB0aGUgcmVxdWVzdGVkIHByZWZldGNoIGlzIFwiZnVsbFwiIGFuZCB0aGUgY3VycmVudCBjYWNoZSBlbnRyeSB3YXNuJ3QsIHdlIHdhbnQgdG8gcmUtcHJlZmV0Y2ggd2l0aCB0aGUgbmV3IGludGVudFxuICAgIGNvbnN0IHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2ggPVxuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgICBraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTFxuXG4gICAgaWYgKHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2gpIHtcbiAgICAgIC8vIElmIHdlIHN3aXRjaGVkIHRvIGEgZnVsbCBwcmVmZXRjaCwgdmFsaWRhdGUgdGhhdCB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgY29udGFpbmVkIHBhcnRpYWwgZGF0YS5cbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgY2FjaGUgZW50cnkgd2FzIHNlZWRlZCB3aXRoIGZ1bGwgZGF0YSBidXQgaGFzIGEgY2FjaGUgdHlwZSBvZiBcImF1dG9cIiAoaWUgd2hlbiBjYWNoZSBlbnRyaWVzXG4gICAgICAvLyBhcmUgc2VlZGVkIGJ1dCB3aXRob3V0IGEgcHJlZmV0Y2ggaW50ZW50KVxuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmRhdGEudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCBpc0Z1bGxQcmVmZXRjaCA9XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShwcmVmZXRjaFJlc3BvbnNlLmZsaWdodERhdGEpICYmXG4gICAgICAgICAgcHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhLnNvbWUoKGZsaWdodERhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIGZyb20gdGhlIHJvb3QgYW5kIHdlIHJldHVybmVkIFJTQyBkYXRhIChzZWVkRGF0YSksIHdlIGFscmVhZHkgaGFkIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgICAgICAgIHJldHVybiBmbGlnaHREYXRhLmlzUm9vdFJlbmRlciAmJiBmbGlnaHREYXRhLnNlZWREYXRhICE9PSBudWxsXG4gICAgICAgICAgfSlcblxuICAgICAgICBpZiAoIWlzRnVsbFByZWZldGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW4gZXhwbGljaXQgcHJlZmV0Y2gga2luZCwgd2Ugd2FudCB0byBzZXQgYSB0ZW1wb3Jhcnkga2luZFxuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYXNzdW1pbmcgdGhlIHNhbWUgaW50ZW50IGFzIHRoZSBwcmV2aW91cyBlbnRyeSwgdG8gYmUgY29uc2lzdGVudCB3aXRoIGhvdyB3ZVxuICAgICAgICAgICAgLy8gbGF6aWx5IGNyZWF0ZSBwcmVmZXRjaCBlbnRyaWVzIHdoZW4gaW50ZW50IGlzIGxlZnQgdW5zcGVjaWZpZWQuXG4gICAgICAgICAgICBraW5kOiBraW5kID8/IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgd2FzIG1hcmtlZCBhcyB0ZW1wb3JhcnksIGl0IG1lYW5zIGl0IHdhcyBsYXppbHkgY3JlYXRlZCB3aGVuIGF0dGVtcHRpbmcgdG8gZ2V0IGFuIGVudHJ5LFxuICAgIC8vIHdoZXJlIHdlIGRpZG4ndCBoYXZlIHRoZSBwcmVmZXRjaCBpbnRlbnQuIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGludGVudCAoaW4gYGtpbmRgKSwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGVudHJ5IHRvIHRoZSBtb3JlIGFjY3VyYXRlIGtpbmQuXG4gICAgaWYgKGtpbmQgJiYgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPT09IFByZWZldGNoS2luZC5URU1QT1JBUlkpIHtcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0ga2luZFxuICAgIH1cblxuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCB0aGUgZXhpc3RpbmcgZW50cnkgd2UgZm91bmQgaXMgc3RpbGwgdmFsaWQsIHNvIHdlIHJldHVybiBpdC5cbiAgICByZXR1cm4gZXhpc3RpbmdDYWNoZUVudHJ5XG4gIH1cblxuICAvLyBJZiB3ZSBkaWRuJ3QgcmV0dXJuIGFuIGVudHJ5LCBjcmVhdGUgYSBuZXcgb25lLlxuICByZXR1cm4gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICAgIHRyZWUsXG4gICAgdXJsLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBraW5kOiBraW5kIHx8IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIH0pXG59XG5cbi8qXG4gKiBVc2VkIHRvIHRha2UgYW4gZXhpc3RpbmcgY2FjaGUgZW50cnkgYW5kIHByZWZpeCBpdCB3aXRoIHRoZSBuZXh0VXJsLCBpZiBpdCBleGlzdHMuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBoYXZlIGNvbmZsaWN0aW5nIGNhY2hlIGVudHJpZXMgZm9yIHRoZSBzYW1lIFVSTCAoYXMgaXMgdGhlIGNhc2Ugd2l0aCByb3V0ZSBpbnRlcmNlcHRpb24pLlxuICovXG5mdW5jdGlvbiBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAgZXhpc3RpbmdDYWNoZUtleSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGV4aXN0aW5nQ2FjaGVLZXk6IHN0cmluZ1xufSkge1xuICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChleGlzdGluZ0NhY2hlS2V5KVxuICBpZiAoIWV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgIC8vIG5vLW9wIC0tIHRoZXJlIHdhc24ndCBhbiBlbnRyeSB0byBtb3ZlXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBuZXdDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gICAgdXJsLFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kLFxuICAgIG5leHRVcmxcbiAgKVxuICBwcmVmZXRjaENhY2hlLnNldChuZXdDYWNoZUtleSwgeyAuLi5leGlzdGluZ0NhY2hlRW50cnksIGtleTogbmV3Q2FjaGVLZXkgfSlcbiAgcHJlZmV0Y2hDYWNoZS5kZWxldGUoZXhpc3RpbmdDYWNoZUtleSlcblxuICByZXR1cm4gbmV3Q2FjaGVLZXlcbn1cblxuLyoqXG4gKiBVc2UgdG8gc2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGUgd2l0aCBkYXRhIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBmZXRjaGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAgdXJsLFxuICBkYXRhLFxuICBraW5kLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3RyZWUnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAgZGF0YTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuICBraW5kOiBQcmVmZXRjaEtpbmRcbn0pIHtcbiAgLy8gVGhlIGluaXRpYWwgY2FjaGUgZW50cnkgdGVjaG5pY2FsbHkgaW5jbHVkZXMgZnVsbCBkYXRhLCBidXQgaXQgaXNuJ3QgZXhwbGljaXRseSBwcmVmZXRjaGVkIC0tIHdlIGp1c3Qgc2VlZCB0aGVcbiAgLy8gcHJlZmV0Y2ggY2FjaGUgc28gdGhhdCB3ZSBjYW4gc2tpcCBhbiBleHRyYSBwcmVmZXRjaCByZXF1ZXN0IGxhdGVyLCBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgdGhlIGRhdGEuXG4gIC8vIGlmIHRoZSBwcmVmZXRjaCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgdXNlIHRoZSBuZXh0VXJsIHRvIHByZWZpeCB0aGUgY2FjaGUga2V5XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBkYXRhLmNvdWxkQmVJbnRlcmNlcHRlZFxuICAgID8gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQsIG5leHRVcmwpXG4gICAgOiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGE6IFByb21pc2UucmVzb2x2ZShkYXRhKSxcbiAgICBraW5kLFxuICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0VXNlZFRpbWU6IERhdGUubm93KCksXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgc3RhdHVzOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2gsXG4gICAgdXJsLFxuICB9IHNhdGlzZmllcyBQcmVmZXRjaENhY2hlRW50cnlcblxuICBwcmVmZXRjaENhY2hlLnNldChwcmVmZXRjaENhY2hlS2V5LCBwcmVmZXRjaEVudHJ5KVxuXG4gIHJldHVybiBwcmVmZXRjaEVudHJ5XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByZWZldGNoIGVudHJ5IGVudHJ5IGFuZCBlbnF1ZXVlcyBhIGZldGNoIHJlcXVlc3QgdG8gcmV0cmlldmUgdGhlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgdXJsLFxuICBraW5kLFxuICB0cmVlLFxuICBuZXh0VXJsLFxuICBwcmVmZXRjaENhY2hlLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3RyZWUnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KTogUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgcHJlZmV0Y2hDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kKVxuXG4gIC8vIGluaXRpYXRlcyB0aGUgZmV0Y2ggcmVxdWVzdCBmb3IgdGhlIHByZWZldGNoIGFuZCBhdHRhY2hlcyBhIGxpc3RlbmVyXG4gIC8vIHRvIHRoZSBwcm9taXNlIHRvIHVwZGF0ZSB0aGUgcHJlZmV0Y2ggY2FjaGUgZW50cnkgd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcyAoaWYgbmVjZXNzYXJ5KVxuICBjb25zdCBkYXRhID0gcHJlZmV0Y2hRdWV1ZS5lbnF1ZXVlKCgpID0+XG4gICAgZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIHtcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlOiB0cmVlLFxuICAgICAgbmV4dFVybCxcbiAgICAgIHByZWZldGNoS2luZDoga2luZCxcbiAgICB9KS50aGVuKChwcmVmZXRjaFJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyBUT0RPOiBgZmV0Y2hTZXJ2ZXJSZXNwb25zZWAgc2hvdWxkIGJlIG1vcmUgdGlnaGx5IGNvdXBsZWQgdG8gdGhlc2UgcHJlZmV0Y2ggY2FjaGUgb3BlcmF0aW9uc1xuICAgICAgLy8gdG8gYXZvaWQgZHJpZnQgYmV0d2VlbiB0aGlzIGNhY2hlIGtleSBwcmVmaXhpbmcgbG9naWNcbiAgICAgIC8vICh3aGljaCBpcyBjdXJyZW50bHkgZGlyZWN0bHkgaW5mbHVlbmNlZCBieSB0aGUgc2VydmVyIHJlc3BvbnNlKVxuICAgICAgbGV0IG5ld0NhY2hlS2V5XG5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLmNvdWxkQmVJbnRlcmNlcHRlZCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBwcmVmaXggdGhlIGNhY2hlIGtleSB3aXRoIHRoZSBuZXh0VXJsXG4gICAgICAgIG5ld0NhY2hlS2V5ID0gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBleGlzdGluZ0NhY2hlS2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHByZWZldGNoIHdhcyBhIGNhY2hlIGhpdCwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHRvIHJlZmxlY3QgdGhhdCBpdCB3YXMgYSBmdWxsIHByZWZldGNoLlxuICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGtub3cgdGhhdCBhIHN0YXRpYyByZXNwb25zZSB3aWxsIGNvbnRhaW4gdGhlIGZ1bGwgUlNDIHBheWxvYWQsIGFuZCBjYW4gYmUgdXBkYXRlZCB0byByZXNwZWN0IHRoZSBgc3RhdGljYFxuICAgICAgLy8gc3RhbGVUaW1lLlxuICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2UucHJlcmVuZGVyZWQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoXG4gICAgICAgICAgLy8gaWYgd2UgcHJlZml4ZWQgdGhlIGNhY2hlIGtleSBkdWUgdG8gcm91dGUgaW50ZXJjZXB0aW9uLCB3ZSB3YW50IHRvIHVzZSB0aGUgbmV3IGtleS4gT3RoZXJ3aXNlIHdlIHVzZSB0aGUgb3JpZ2luYWwga2V5XG4gICAgICAgICAgbmV3Q2FjaGVLZXkgPz8gcHJlZmV0Y2hDYWNoZUtleVxuICAgICAgICApXG4gICAgICAgIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAgICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IFByZWZldGNoS2luZC5GVUxMXG4gICAgICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3RhbGUgdGltZSB0aGF0IHdhcyBjb2xsZWN0ZWQgYnkgdGhlIHNlcnZlciBkdXJpbmdcbiAgICAgICAgICAgIC8vIHN0YXRpYyBnZW5lcmF0aW9uLiBVc2UgdGhpcyBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBzdGFsZSB0aW1lLlxuICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YWxlVGltZSA9IHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVmZXRjaFJlc3BvbnNlXG4gICAgfSlcbiAgKVxuXG4gIGNvbnN0IHByZWZldGNoRW50cnkgPSB7XG4gICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgZGF0YSxcbiAgICBraW5kLFxuICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0VXNlZFRpbWU6IG51bGwsXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgc3RhdHVzOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2gsXG4gICAgdXJsLFxuICB9XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJ1bmVQcmVmZXRjaENhY2hlKFxuICBwcmVmZXRjaENhY2hlOiBSZWFkb25seVJlZHVjZXJTdGF0ZVsncHJlZmV0Y2hDYWNoZSddXG4pIHtcbiAgZm9yIChjb25zdCBbaHJlZiwgcHJlZmV0Y2hDYWNoZUVudHJ5XSBvZiBwcmVmZXRjaENhY2hlKSB7XG4gICAgaWYgKFxuICAgICAgZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHByZWZldGNoQ2FjaGVFbnRyeSkgPT09XG4gICAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZXhwaXJlZFxuICAgICkge1xuICAgICAgcHJlZmV0Y2hDYWNoZS5kZWxldGUoaHJlZilcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlc2UgdmFsdWVzIGFyZSBzZXQgYnkgYGRlZmluZS1lbnYtcGx1Z2luYCAoYmFzZWQgb24gYG5leHRDb25maWcuZXhwZXJpbWVudGFsLnN0YWxlVGltZXNgKVxuLy8gYW5kIGRlZmF1bHQgdG8gNSBtaW51dGVzIChzdGF0aWMpIC8gMCBzZWNvbmRzIChkeW5hbWljKVxuY29uc3QgRFlOQU1JQ19TVEFMRVRJTUVfTVMgPVxuICBOdW1iZXIocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUpICogMTAwMFxuXG5leHBvcnQgY29uc3QgU1RBVElDX1NUQUxFVElNRV9NUyA9XG4gIE51bWJlcihwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FKSAqIDEwMDBcblxuZnVuY3Rpb24gZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHtcbiAga2luZCxcbiAgcHJlZmV0Y2hUaW1lLFxuICBsYXN0VXNlZFRpbWUsXG4gIHN0YWxlVGltZSxcbn06IFByZWZldGNoQ2FjaGVFbnRyeSk6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyB7XG4gIGlmIChzdGFsZVRpbWUgIT09IC0xKSB7XG4gICAgLy8gYHN0YWxlVGltZWAgaXMgdGhlIHZhbHVlIHNlbnQgYnkgdGhlIHNlcnZlciBkdXJpbmcgc3RhdGljIGdlbmVyYXRpb24uXG4gICAgLy8gV2hlbiB0aGlzIGlzIGF2YWlsYWJsZSwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFueSBvZiB0aGUgaGV1cmlzdGljc1xuICAgIC8vIHRoYXQgZm9sbG93LlxuICAgIC8vXG4gICAgLy8gVE9ETzogV2hlbiBQUFIgaXMgZW5hYmxlZCwgdGhlIHNlcnZlciB3aWxsICphbHdheXMqIHJldHVybiBhIHN0YWxlIHRpbWVcbiAgICAvLyB3aGVuIHByZWZldGNoaW5nLiBXZSBzaG91bGQgbmV2ZXIgdXNlIGEgcHJlZmV0Y2ggZW50cnkgdGhhdCBoYXNuJ3QgeWV0XG4gICAgLy8gcmVjZWl2ZWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuIFNvIHRoZSBvbmx5IHR3byBjYXNlcyBzaG91bGQgYmUgMSkgd2UgdXNlXG4gICAgLy8gdGhlIHNlcnZlci1nZW5lcmF0ZWQgc3RhbGUgdGltZSAyKSB0aGUgdW5yZXNvbHZlZCBlbnRyeSBpcyBkaXNjYXJkZWQuXG4gICAgcmV0dXJuIERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBzdGFsZVRpbWVcbiAgICAgID8gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoXG4gICAgICA6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZVxuICB9XG5cbiAgLy8gV2Ugd2lsbCByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGRhdGEgZm9yIHVwIHRvIHRoZSBgZHluYW1pY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgaWYgKERhdGUubm93KCkgPCAobGFzdFVzZWRUaW1lID8/IHByZWZldGNoVGltZSkgKyBEWU5BTUlDX1NUQUxFVElNRV9NUykge1xuICAgIHJldHVybiBsYXN0VXNlZFRpbWVcbiAgICAgID8gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnJldXNhYmxlXG4gICAgICA6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaFxuICB9XG5cbiAgLy8gRm9yIFwiYXV0b1wiIHByZWZldGNoaW5nLCB3ZSdsbCByZS11c2Ugb25seSB0aGUgbG9hZGluZyBib3VuZGFyeSBmb3IgdXAgdG8gYHN0YXRpY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgLy8gQSBzdGFsZSBlbnRyeSB3aWxsIG9ubHkgcmUtdXNlIHRoZSBgbG9hZGluZ2AgYm91bmRhcnksIG5vdCB0aGUgZnVsbCBkYXRhLlxuICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIFwibGF6eSBmZXRjaFwiIGZvciB0aGUgZnVsbCBkYXRhLlxuICBpZiAoa2luZCA9PT0gUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuc3RhbGVcbiAgICB9XG4gIH1cblxuICAvLyBmb3IgXCJmdWxsXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gYHN0YXRpY2Agc3RhbGV0aW1lIHdpbmRvdy5cbiAgaWYgKGtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMKSB7XG4gICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnJldXNhYmxlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5leHBpcmVkXG59XG4iXSwibmFtZXMiOlsiU1RBVElDX1NUQUxFVElNRV9NUyIsImNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwicHJ1bmVQcmVmZXRjaENhY2hlIiwiSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIiLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbCIsInVybCIsImluY2x1ZGVTZWFyY2hQYXJhbXMiLCJwcmVmaXgiLCJwYXRobmFtZUZyb21VcmwiLCJwYXRobmFtZSIsInNlYXJjaCIsImNyZWF0ZVByZWZldGNoQ2FjaGVLZXkiLCJraW5kIiwibmV4dFVybCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJnZXRFeGlzdGluZ0NhY2hlRW50cnkiLCJwcmVmZXRjaENhY2hlIiwiYWxsb3dBbGlhc2luZyIsIlRFTVBPUkFSWSIsIm1heWJlTmV4dFVybCIsImNhY2hlS2V5V2l0aFBhcmFtcyIsImNhY2hlS2V5V2l0aG91dFBhcmFtcyIsImNhY2hlS2V5VG9Vc2UiLCJleGlzdGluZ0VudHJ5IiwiZ2V0IiwiaXNBbGlhc2VkIiwiYWxpYXNlZCIsImVudHJ5V2l0aG91dFBhcmFtcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImtleSIsImluY2x1ZGVzIiwiY2FjaGVFbnRyeSIsInZhbHVlcyIsInVuZGVmaW5lZCIsInRyZWUiLCJleGlzdGluZ0NhY2hlRW50cnkiLCJzdGF0dXMiLCJnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMiLCJzd2l0Y2hlZFRvRnVsbFByZWZldGNoIiwiZGF0YSIsInRoZW4iLCJwcmVmZXRjaFJlc3BvbnNlIiwiaXNGdWxsUHJlZmV0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJmbGlnaHREYXRhIiwic29tZSIsImlzUm9vdFJlbmRlciIsInNlZWREYXRhIiwiY3JlYXRlTGF6eVByZWZldGNoRW50cnkiLCJwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSIsImV4aXN0aW5nQ2FjaGVLZXkiLCJuZXdDYWNoZUtleSIsInNldCIsImRlbGV0ZSIsInByZWZldGNoQ2FjaGVLZXkiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVmZXRjaEVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInByZWZldGNoVGltZSIsIkRhdGUiLCJub3ciLCJsYXN0VXNlZFRpbWUiLCJzdGFsZVRpbWUiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJmcmVzaCIsInByZWZldGNoUXVldWUiLCJlbnF1ZXVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImZsaWdodFJvdXRlclN0YXRlIiwicHJlZmV0Y2hLaW5kIiwicHJlcmVuZGVyZWQiLCJocmVmIiwicHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhwaXJlZCIsIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiTnVtYmVyIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FIiwic3RhbGUiLCJyZXVzYWJsZSIsIkFVVE8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3FEQTZIYUE7OztlQUFBQTs7O2lEQTdIdUI7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7NkNBQ0U7dUNBRUs7bURBQ0M7K0RBQ1k7QUFFbEQsd0ZBQXdGO0FBQ3hGLFNBQVNDLHNCQUNQQyxLQUEyQixFQUMzQkMsTUFBd0I7SUFFeEIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CRixRQUFRRywwQkFBMEIsR0FBRztJQUVyQyxNQUFNQyxRQUFtQkMsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQUFBO0lBQ3pCLHNGQUFzRjtJQUN0RixzSEFBc0g7SUFDdEgsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQWlDLEVBQUNWLE1BQU1XLElBQUk7SUFFbkUsdURBQXVEO0lBQ3ZELHdDQUF3QztJQUN4Q0osTUFBTUssUUFBUSxHQUFHQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQUFBLEVBQW9CLElBQUlDLElBQUlWLE1BQU1GLFNBQVM7UUFDMURhLG1CQUFtQjtZQUFDZixNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFO1NBQVU7UUFDM0VLLFNBQVNQLGlCQUFpQlQsTUFBTWdCLE9BQU8sR0FBRztRQUMxQ0MsY0FBYztJQUNoQjtJQUVBLE9BQU9WLE1BQU1LLFFBQVEsQ0FBQ00sSUFBSSxDQUN4QjtZQUFDLEVBQUVDLFVBQVUsRUFBRWQsY0FBY2Usb0JBQW9CLEVBQUU7UUFDakQsNERBQTREO1FBQzVELElBQUksT0FBT0QsZUFBZSxVQUFVO1lBQ2xDLE9BQU9FLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHJCLE9BQ0FHLFNBQ0FnQixZQUNBbkIsTUFBTXNCLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLCtEQUErRDtRQUMvRGhCLE1BQU1LLFFBQVEsR0FBRztRQUVqQixJQUFJWSxjQUFjeEIsTUFBTVcsSUFBSTtRQUM1QixJQUFJYyxlQUFlekIsTUFBTU8sS0FBSztRQUU5QixLQUFLLE1BQU1tQix3QkFBd0JQLFdBQVk7WUFDN0MsTUFBTSxFQUFFUixNQUFNZ0IsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR0Y7WUFDMUMsSUFBSSxDQUFDRSxjQUFjO2dCQUNqQixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBTzlCO1lBQ1Q7WUFFQSxNQUFNK0IsVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUNkO2dCQUNDO2FBQUcsRUFDSlIsYUFDQUcsV0FDQTNCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSTBCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFBQSxFQUFzQmpDLE9BQU9DLFFBQVEwQjtZQUM5QztZQUVBLElBQUlPLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFBNEJWLGFBQWFPLFVBQVU7Z0JBQ3JELE9BQU9WLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHJCLE9BQ0FHLFNBQ0FDLE1BQ0FKLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7WUFFN0I7WUFFQSxNQUFNWSwyQkFBMkJmLHVCQUM3QmdCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JoQix3QkFDbEJpQjtZQUVKLElBQUlqQixzQkFBc0I7Z0JBQ3hCakIsUUFBUUUsWUFBWSxHQUFHOEI7WUFDekI7WUFDQSxNQUFNRyxVQUFVQyxDQUFBQSxHQUFBQSxpQkFBQUEsZUFBQUEsRUFDZGQsY0FDQWxCLE9BQ0FtQjtZQUdGLElBQUlZLFNBQVM7Z0JBQ1huQyxRQUFRSSxLQUFLLEdBQUdBO2dCQUNoQmtCLGVBQWVsQjtZQUNqQjtZQUVBSixRQUFRcUMsV0FBVyxHQUFHVDtZQUN0QjVCLFFBQVFFLFlBQVksR0FBR0Q7WUFFdkJvQixjQUFjTztRQUNoQjtRQUNBLE9BQU9VLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWN6QyxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVY7QUFFQSxTQUFTMEMsc0JBQ1AxQyxLQUEyQixFQUMzQjJDLE9BQXlCO0lBRXpCLE9BQU8zQztBQUNUO0FBRU8sTUFBTUYsb0JBQ1g4QyxNQUFvQixHQUNoQkYsQ0FBcUJBLEdBQ3JCM0MiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxobXItcmVmcmVzaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgSG1yUmVmcmVzaEFjdGlvbixcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcblxuLy8gQSB2ZXJzaW9uIG9mIHJlZnJlc2ggcmVkdWNlciB0aGF0IGtlZXBzIHRoZSBjYWNoZSBhcm91bmQgaW5zdGVhZCBvZiB3aXBpbmcgYWxsIG9mIGl0LlxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJJbXBsKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBNdXRhYmxlID0ge31cbiAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybFxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlZnJlc2ggcmVxdWVzdCBkb2Vzbid0IGdldCBpbnRlcmNlcHRlZCwgYWNjaWRlbnRhbGx5IHRyaWdnZXJpbmcgdGhlIGludGVyY2VwdGlvbiByb3V0ZS5cbiAgY29uc3QgaW5jbHVkZU5leHRVcmwgPSBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoc3RhdGUudHJlZSlcblxuICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgY2FjaGUubGF6eURhdGEgPSBmZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwge1xuICAgIGZsaWdodFJvdXRlclN0YXRlOiBbc3RhdGUudHJlZVswXSwgc3RhdGUudHJlZVsxXSwgc3RhdGUudHJlZVsyXSwgJ3JlZmV0Y2gnXSxcbiAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsLFxuICAgIGlzSG1yUmVmcmVzaDogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gY2FjaGUubGF6eURhdGEudGhlbihcbiAgICAoeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlIH0pID0+IHtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgY2FjaGUubGF6eURhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbFxuXG4gICAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG4gICAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGVcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdHJlZTogdHJlZVBhdGNoLCBpc1Jvb3RSZW5kZXIgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JFRlJFU0ggRkFJTEVEJylcbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgIFsnJ10sXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlU2VnbWVudE1pc21hdGNoKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICAgID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpXG4gICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGxpZWQgPSBhcHBseUZsaWdodERhdGEoXG4gICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIClcblxuICAgICAgICBpZiAoYXBwbGllZCkge1xuICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlXG4gICAgICAgIH1cblxuICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZVxuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWZcblxuICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH0sXG4gICAgKCkgPT4gc3RhdGVcbiAgKVxufVxuXG5mdW5jdGlvbiBobXJSZWZyZXNoUmVkdWNlck5vb3AoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgX2FjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCBobXJSZWZyZXNoUmVkdWNlciA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcbiAgICA/IGhtclJlZnJlc2hSZWR1Y2VyTm9vcFxuICAgIDogaG1yUmVmcmVzaFJlZHVjZXJJbXBsXG4iXSwibmFtZXMiOlsiaG1yUmVmcmVzaFJlZHVjZXIiLCJobXJSZWZyZXNoUmVkdWNlckltcGwiLCJzdGF0ZSIsImFjdGlvbiIsIm9yaWdpbiIsIm11dGFibGUiLCJocmVmIiwiY2Fub25pY2FsVXJsIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiaW5jbHVkZU5leHRVcmwiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJ0cmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwiaXNIbXJSZWZyZXNoIiwidGhlbiIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImhhbmRsZUV4dGVybmFsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwiY3VycmVudFRyZWUiLCJjdXJyZW50Q2FjaGUiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWVQYXRjaCIsImlzUm9vdFJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJhcHBsaWVkIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiaG1yUmVmcmVzaFJlZHVjZXJOb29wIiwiX2FjdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _stitchederror = __webpack_require__(/*! ../components/errors/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/stitched-error.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../components/errors/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/use-error-handler.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _interceptconsoleerror = __webpack_require__(/*! ../components/globals/intercept-console-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js\");\nconst _errorboundary = __webpack_require__(/*! ../components/error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nfunction onCaughtError(err, errorInfo) {\n    var _errorInfo_errorBoundary;\n    const errorBoundaryComponent = (_errorInfo_errorBoundary = errorInfo.errorBoundary) == null ? void 0 : _errorInfo_errorBoundary.constructor;\n    let isImplicitErrorBoundary;\n    if (true) {\n        const { AppDevOverlayErrorBoundary } = __webpack_require__(/*! ../components/react-dev-overlay/app/app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay-error-boundary.js\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _errorboundary.GlobalError;\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(err, errorInfo);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        var _errorInfo_componentStack;\n        const errorBoundaryName = (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.displayName) || (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.name) || 'Unknown';\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = \"It was handled by the <\" + errorBoundaryName + \"> error boundary.\";\n        const componentErrorMessage = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const errorLocation = componentErrorMessage + \" \" + errorBoundaryMessage;\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // Log and report the error with location but without modifying the error stack\n        (0, _interceptconsoleerror.originConsoleError)('%o\\n\\n%s', err, errorLocation);\n        (0, _useerrorhandler.handleClientError)(stitchedError, []);\n    } else {}\n}\nfunction onUncaughtError(err, errorInfo) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(stitchedError);\n    } else {}\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlGQUFpRjs7Ozs7Ozs7Ozs7OztJQWNqRUEsYUFBYTtlQUFiQTs7SUF5RUFDLGVBQWU7ZUFBZkE7OzsyQ0FwRnNCOzZDQUNKOytDQUNBOzBDQUNFOytDQUNGO21EQUNDOzJDQUk1QjtBQUVBLFNBQVNELGNBQ2RFLEdBQVksRUFDWkMsU0FBMEQ7UUFFM0JBO0lBQS9CLE1BQU1DLHlCQUFBQSxDQUF5QkQsMkJBQUFBLFVBQVVFLGFBQWEscUJBQXZCRix5QkFBeUJHLFdBQVc7SUFFbkUsSUFBSUM7SUFFSixJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNLEVBQUVHLDBCQUEwQixFQUFFLEdBQ2xDQyxtQkFBT0EsQ0FBQyxrTUFBb0U7UUFFOUVMLDBCQUNFSCwyQkFBMkJPO0lBQy9CO0lBRUFKLDBCQUNFQSwyQkFDQ0gsMkJBQTJCUyxlQUFBQSxvQkFBb0IsSUFDN0NWLFVBQVVFLGFBQWEsQ0FDckJTLEtBQUssQ0FBQ0MsY0FBYyxLQUFLQyxlQUFBQSxXQUFvQjtJQUVwRCxJQUFJVCx5QkFBeUI7UUFDM0IsNkVBQTZFO1FBQzdFLHVEQUF1RDtRQUN2RCw2REFBNkQ7UUFDN0QsT0FBT04sZ0JBQWdCQyxLQUFLQztJQUM5QjtJQUVBLDZFQUE2RTtJQUM3RSxJQUFJYyxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBQUEsRUFBb0JmLFFBQVFnQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCaEIsTUFBTTtJQUV4RCxJQUFJTSxJQUFvQixFQUFtQjtZQU9QTDtRQU5sQyxNQUFNZ0Isb0JBRUosQ0FEQSwwQkFDQ2YsT0FBQUEsRUFEa0MsR0FDbENBLElBQUFBLHVCQUFnQ2dCLFdBQUFBLE1BQ2pDaEIsMEJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHVCQUF3QmlCLElBQUksS0FDNUI7UUFFRixNQUFNQyw0QkFBNEJuQixhQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSw0QkFBQUEsVUFBV29CLGNBQUFBLEtBQWMsZ0JBQXpCcEIsMEJBQTJCcUIsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBSXpFLHNEQUFzRCwrQ0FDK0M7UUFDckcsZ0dBQWdHO1FBQ2hHRjtRQUxGLHFDQUFxQztRQUNyQyxNQUFNRyxVQUlKSCxDQUFBQSxtQ0FBQUEsNkJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLDBCQUEyQkksS0FBSyxDQUFDLG9DQUFqQ0osbUNBQTZELEVBQUU7UUFDakUsTUFBTUssMkJBQTJCRixPQUFPLENBQUMsRUFBRSxJQUFJQSxPQUFPLENBQUMsRUFBRSxJQUFJO1FBRTdELGlJQUFpSTtRQUNqSSxNQUFNRyx1QkFBd0IsNEJBQXlCVCxvQkFBa0I7UUFDekUsTUFBTVUsd0JBQXdCRiwyQkFDekIsc0NBQW1DQSwyQkFBeUIsaUJBQzVEO1FBRUwsTUFBTUcsZ0JBQW1CRCx3QkFBc0IsTUFBR0Q7UUFFbEQsTUFBTUcsZ0JBQWdCQyxDQUFBQSxHQUFBQSxlQUFBQSxxQkFBQUEsRUFBc0I5QjtRQUM1QywrQ0FBK0M7UUFDL0MsbUVBQW1FO1FBQ25FLElBQUlDLFVBQVVvQixjQUFjLEVBQUU7O1lBQzFCUSxjQUFzQkUsZUFBZSxHQUFHOUIsVUFBVW9CLGNBQWM7UUFDcEU7UUFFQSwrRUFBK0U7UUFDL0VXLENBQUFBLEdBQUFBLHVCQUFBQSxrQkFBQUEsRUFBbUIsWUFBWWhDLEtBQUs0QjtRQUVwQ0ssQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUFrQkosZUFBZSxFQUFFO0lBQ3JDLE9BQU8sRUFFTjtBQUNIO0FBRU8sU0FBUzlCLGdCQUFnQkMsR0FBWSxFQUFFQyxTQUEwQjtJQUN0RSw2RUFBNkU7SUFDN0UsSUFBSWMsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CZixRQUFRZ0IsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQmhCLE1BQU07SUFFeEQsSUFBSU0sSUFBb0IsRUFBbUI7UUFDekMsTUFBTXVCLGdCQUFnQkMsQ0FBQUEsR0FBQUEsZUFBQUEscUJBQUFBLEVBQXNCOUI7UUFDNUMsK0NBQStDO1FBQy9DLG1FQUFtRTtRQUNuRSxJQUFJQyxVQUFVb0IsY0FBYyxFQUFFOztZQUMxQlEsY0FBc0JFLGVBQWUsR0FBRzlCLFVBQVVvQixjQUFjO1FBQ3BFO1FBRUEsb0ZBQW9GO1FBQ3BGYSxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCTDtJQUNwQixPQUFPLEVBRU47QUFDSCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWtpX1xcc3JjXFxjbGllbnRcXHJlYWN0LWNsaWVudC1jYWxsYmFja3NcXGVycm9yLWJvdW5kYXJ5LWNhbGxiYWNrcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgb25seSB1c2VkIGluIGFwcCByb3V0ZXIgZHVlIHRvIHRoZSBzcGVjaWZpYyBlcnJvciBzdGF0ZSBoYW5kbGluZy5cblxuaW1wb3J0IHR5cGUgeyBFcnJvckluZm8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGdldFJlYWN0U3RpdGNoZWRFcnJvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvZXJyb3JzL3N0aXRjaGVkLWVycm9yJ1xuaW1wb3J0IHsgaGFuZGxlQ2xpZW50RXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL2Vycm9ycy91c2UtZXJyb3ItaGFuZGxlcidcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHJlcG9ydEdsb2JhbEVycm9yIH0gZnJvbSAnLi9yZXBvcnQtZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgb3JpZ2luQ29uc29sZUVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9nbG9iYWxzL2ludGVyY2VwdC1jb25zb2xlLWVycm9yJ1xuaW1wb3J0IHtcbiAgRXJyb3JCb3VuZGFyeUhhbmRsZXIsXG4gIEdsb2JhbEVycm9yIGFzIERlZmF1bHRFcnJvckJvdW5kYXJ5LFxufSBmcm9tICcuLi9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5J1xuXG5leHBvcnQgZnVuY3Rpb24gb25DYXVnaHRFcnJvcihcbiAgZXJyOiB1bmtub3duLFxuICBlcnJvckluZm86IEVycm9ySW5mbyAmIHsgZXJyb3JCb3VuZGFyeT86IFJlYWN0LkNvbXBvbmVudCB9XG4pIHtcbiAgY29uc3QgZXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9IGVycm9ySW5mby5lcnJvckJvdW5kYXJ5Py5jb25zdHJ1Y3RvclxuXG4gIGxldCBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSB9ID1cbiAgICAgIHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeScpXG5cbiAgICBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSA9XG4gICAgICBlcnJvckJvdW5kYXJ5Q29tcG9uZW50ID09PSBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVxuICB9XG5cbiAgaXNJbXBsaWNpdEVycm9yQm91bmRhcnkgPVxuICAgIGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5IHx8XG4gICAgKGVycm9yQm91bmRhcnlDb21wb25lbnQgPT09IEVycm9yQm91bmRhcnlIYW5kbGVyICYmXG4gICAgICAoZXJyb3JJbmZvLmVycm9yQm91bmRhcnkhIGFzIEluc3RhbmNlVHlwZTx0eXBlb2YgRXJyb3JCb3VuZGFyeUhhbmRsZXI+KVxuICAgICAgICAucHJvcHMuZXJyb3JDb21wb25lbnQgPT09IERlZmF1bHRFcnJvckJvdW5kYXJ5KVxuXG4gIGlmIChpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIFdlIGRvbid0IGNvbnNpZGVyIGVycm9ycyBjYXVnaHQgdW5sZXNzIHRoZXkncmUgY2F1Z2h0IGJ5IGFuIGV4cGxpY2l0IGVycm9yXG4gICAgLy8gYm91bmRhcnkuIFRoZSBidWlsdC1pbiBvbmVzIGFyZSBjb25zaWRlcmVkIGltcGxpY2l0LlxuICAgIC8vIFRoaXMgbWltaWNzIGhvdyB0aGUgc2FtZSBhcHAgd291bGQgYmVoYXZlIHdpdGhvdXQgTmV4dC5qcy5cbiAgICByZXR1cm4gb25VbmNhdWdodEVycm9yKGVyciwgZXJyb3JJbmZvKVxuICB9XG5cbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IoZXJyKSB8fCBpc05leHRSb3V0ZXJFcnJvcihlcnIpKSByZXR1cm5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGVycm9yQm91bmRhcnlOYW1lID1cbiAgICAgIC8vIHJlYWQgcmVhY3QgY29tcG9uZW50IGRpc3BsYXlOYW1lXG4gICAgICAoZXJyb3JCb3VuZGFyeUNvbXBvbmVudCBhcyBhbnkpPy5kaXNwbGF5TmFtZSB8fFxuICAgICAgZXJyb3JCb3VuZGFyeUNvbXBvbmVudD8ubmFtZSB8fFxuICAgICAgJ1Vua25vd24nXG5cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lID0gZXJyb3JJbmZvPy5jb21wb25lbnRTdGFjaz8uc3BsaXQoJ1xcbicpWzFdXG5cbiAgICAvLyBNYXRjaCBjaHJvbWUgb3Igc2FmYXJpIHN0YWNrIHRyYWNlXG4gICAgY29uc3QgbWF0Y2hlcyA9XG4gICAgICAvLyByZWdleCB0byBtYXRjaCB0aGUgZnVuY3Rpb24gbmFtZSBpbiB0aGUgc3RhY2sgdHJhY2VcbiAgICAgIC8vIGV4YW1wbGUgMTogYXQgUGFnZSAoaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjEpXG4gICAgICAvLyBleGFtcGxlIDI6IFBhZ2VAaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjFcbiAgICAgIGNvbXBvbmVudFRoYXRFcnJvcmVkRnJhbWU/Lm1hdGNoKC9cXHMrYXQgKFxcdyspXFxzK3woXFx3KylALykgPz8gW11cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZE5hbWUgPSBtYXRjaGVzWzFdIHx8IG1hdGNoZXNbMl0gfHwgJ1Vua25vd24nXG5cbiAgICAvLyBDcmVhdGUgZXJyb3IgbG9jYXRpb24gd2l0aCBlcnJvcmVkIGNvbXBvbmVudCBhbmQgZXJyb3IgYm91bmRhcnksIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZiBkZWZhdWx0IFJlYWN0IG9uQ2F1Z2h0RXJyb3IgaGFuZGxlci5cbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IGBJdCB3YXMgaGFuZGxlZCBieSB0aGUgPCR7ZXJyb3JCb3VuZGFyeU5hbWV9PiBlcnJvciBib3VuZGFyeS5gXG4gICAgY29uc3QgY29tcG9uZW50RXJyb3JNZXNzYWdlID0gY29tcG9uZW50VGhhdEVycm9yZWROYW1lXG4gICAgICA/IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwke2NvbXBvbmVudFRoYXRFcnJvcmVkTmFtZX0+IGNvbXBvbmVudC5gXG4gICAgICA6IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgY29tcG9uZW50cy5gXG5cbiAgICBjb25zdCBlcnJvckxvY2F0aW9uID0gYCR7Y29tcG9uZW50RXJyb3JNZXNzYWdlfSAke2Vycm9yQm91bmRhcnlNZXNzYWdlfWBcblxuICAgIGNvbnN0IHN0aXRjaGVkRXJyb3IgPSBnZXRSZWFjdFN0aXRjaGVkRXJyb3IoZXJyKVxuICAgIC8vIFRPRE86IGNoYW5nZSB0byBwYXNzaW5nIGRvd24gZXJyb3JJbmZvIGxhdGVyXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgcGFzcyBhbG9uZyB0aGUgY29tcG9uZW50IHN0YWNrIHRvIHRoZSBlcnJvclxuICAgIGlmIChlcnJvckluZm8uY29tcG9uZW50U3RhY2spIHtcbiAgICAgIDsoc3RpdGNoZWRFcnJvciBhcyBhbnkpLl9jb21wb25lbnRTdGFjayA9IGVycm9ySW5mby5jb21wb25lbnRTdGFja1xuICAgIH1cblxuICAgIC8vIExvZyBhbmQgcmVwb3J0IHRoZSBlcnJvciB3aXRoIGxvY2F0aW9uIGJ1dCB3aXRob3V0IG1vZGlmeWluZyB0aGUgZXJyb3Igc3RhY2tcbiAgICBvcmlnaW5Db25zb2xlRXJyb3IoJyVvXFxuXFxuJXMnLCBlcnIsIGVycm9yTG9jYXRpb24pXG5cbiAgICBoYW5kbGVDbGllbnRFcnJvcihzdGl0Y2hlZEVycm9yLCBbXSlcbiAgfSBlbHNlIHtcbiAgICBvcmlnaW5Db25zb2xlRXJyb3IoZXJyKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyOiB1bmtub3duLCBlcnJvckluZm86IFJlYWN0LkVycm9ySW5mbykge1xuICAvLyBTa2lwIGNlcnRhaW4gY3VzdG9tIGVycm9ycyB3aGljaCBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIHJlcG9ydGVkIG9uIGNsaWVudFxuICBpZiAoaXNCYWlsb3V0VG9DU1JFcnJvcihlcnIpIHx8IGlzTmV4dFJvdXRlckVycm9yKGVycikpIHJldHVyblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3Qgc3RpdGNoZWRFcnJvciA9IGdldFJlYWN0U3RpdGNoZWRFcnJvcihlcnIpXG4gICAgLy8gVE9ETzogY2hhbmdlIHRvIHBhc3NpbmcgZG93biBlcnJvckluZm8gbGF0ZXJcbiAgICAvLyBJbiBkZXZlbG9wbWVudCBtb2RlLCBwYXNzIGFsb25nIHRoZSBjb21wb25lbnQgc3RhY2sgdG8gdGhlIGVycm9yXG4gICAgaWYgKGVycm9ySW5mby5jb21wb25lbnRTdGFjaykge1xuICAgICAgOyhzdGl0Y2hlZEVycm9yIGFzIGFueSkuX2NvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrXG4gICAgfVxuXG4gICAgLy8gVE9ETzogQWRkIGFuIGFkZW5kdW0gdG8gdGhlIG92ZXJsYXkgdGVsbGluZyBwZW9wbGUgYWJvdXQgY3VzdG9tIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgcmVwb3J0R2xvYmFsRXJyb3Ioc3RpdGNoZWRFcnJvcilcbiAgfSBlbHNlIHtcbiAgICByZXBvcnRHbG9iYWxFcnJvcihlcnIpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJvbkNhdWdodEVycm9yIiwib25VbmNhdWdodEVycm9yIiwiZXJyIiwiZXJyb3JJbmZvIiwiZXJyb3JCb3VuZGFyeUNvbXBvbmVudCIsImVycm9yQm91bmRhcnkiLCJjb25zdHJ1Y3RvciIsImlzSW1wbGljaXRFcnJvckJvdW5kYXJ5IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkiLCJyZXF1aXJlIiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJwcm9wcyIsImVycm9yQ29tcG9uZW50IiwiRGVmYXVsdEVycm9yQm91bmRhcnkiLCJpc0JhaWxvdXRUb0NTUkVycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJlcnJvckJvdW5kYXJ5TmFtZSIsImRpc3BsYXlOYW1lIiwibmFtZSIsImNvbXBvbmVudFRoYXRFcnJvcmVkRnJhbWUiLCJjb21wb25lbnRTdGFjayIsInNwbGl0IiwibWF0Y2hlcyIsIm1hdGNoIiwiY29tcG9uZW50VGhhdEVycm9yZWROYW1lIiwiZXJyb3JCb3VuZGFyeU1lc3NhZ2UiLCJjb21wb25lbnRFcnJvck1lc3NhZ2UiLCJlcnJvckxvY2F0aW9uIiwic3RpdGNoZWRFcnJvciIsImdldFJlYWN0U3RpdGNoZWRFcnJvciIsIl9jb21wb25lbnRTdGFjayIsIm9yaWdpbkNvbnNvbGVFcnJvciIsImhhbmRsZUNsaWVudEVycm9yIiwicmVwb3J0R2xvYmFsRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This module can be shared between both pages router and app router\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"onRecoverableError\", ({\n    enumerable: true,\n    get: function() {\n        return onRecoverableError;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _stitchederror = __webpack_require__(/*! ../components/errors/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/stitched-error.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../lib/is-error */ \"(app-pages-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst onRecoverableError = (error, errorInfo)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    const cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    const stitchedError = (0, _stitchederror.getReactStitchedError)(cause);\n    // In development mode, pass along the component stack to the error\n    if ( true && errorInfo.componentStack) {\n        ;\n        stitchedError._componentStack = errorInfo.componentStack;\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    (0, _reportglobalerror.reportGlobalError)(stitchedError);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=on-recoverable-error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUEscUVBQXFFOzs7OztzREFReERBOzs7ZUFBQUE7Ozs7MENBTHVCOytDQUNGOzJDQUNJOzhFQUNsQjtBQUViLE1BQU1BLHFCQUE2RCxDQUN4RUMsT0FDQUM7SUFFQSxzREFBc0Q7SUFDdEQsTUFBTUMsUUFBUUMsQ0FBQUEsR0FBQUEsU0FBQUEsT0FBQUEsRUFBUUgsVUFBVSxXQUFXQSxRQUFRQSxNQUFNRSxLQUFLLEdBQUdGO0lBQ2pFLE1BQU1JLGdCQUFnQkMsQ0FBQUEsR0FBQUEsZUFBQUEscUJBQUFBLEVBQXNCSDtJQUM1QyxtRUFBbUU7SUFDbkUsSUFBSUksS0FBb0IsSUFBc0JMLFVBQVVRLGNBQWMsRUFBRTs7UUFDcEVMLGNBQXNCTSxlQUFlLEdBQUdULFVBQVVRLGNBQWM7SUFDcEU7SUFDQSw2RUFBNkU7SUFDN0UsSUFBSUUsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CVCxRQUFRO0lBRWhDVSxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCUjtBQUNwQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWtpX1xcc3JjXFxjbGllbnRcXHJlYWN0LWNsaWVudC1jYWxsYmFja3NcXG9uLXJlY292ZXJhYmxlLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgbW9kdWxlIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBib3RoIHBhZ2VzIHJvdXRlciBhbmQgYXBwIHJvdXRlclxuXG5pbXBvcnQgdHlwZSB7IEh5ZHJhdGlvbk9wdGlvbnMgfSBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IHsgaXNCYWlsb3V0VG9DU1JFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2JhaWxvdXQtdG8tY3NyJ1xuaW1wb3J0IHsgcmVwb3J0R2xvYmFsRXJyb3IgfSBmcm9tICcuL3JlcG9ydC1nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBnZXRSZWFjdFN0aXRjaGVkRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL2Vycm9ycy9zdGl0Y2hlZC1lcnJvcidcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4uLy4uL2xpYi9pcy1lcnJvcidcblxuZXhwb3J0IGNvbnN0IG9uUmVjb3ZlcmFibGVFcnJvcjogSHlkcmF0aW9uT3B0aW9uc1snb25SZWNvdmVyYWJsZUVycm9yJ10gPSAoXG4gIGVycm9yLFxuICBlcnJvckluZm9cbikgPT4ge1xuICAvLyB4LXJlZjogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjg3MzZcbiAgY29uc3QgY2F1c2UgPSBpc0Vycm9yKGVycm9yKSAmJiAnY2F1c2UnIGluIGVycm9yID8gZXJyb3IuY2F1c2UgOiBlcnJvclxuICBjb25zdCBzdGl0Y2hlZEVycm9yID0gZ2V0UmVhY3RTdGl0Y2hlZEVycm9yKGNhdXNlKVxuICAvLyBJbiBkZXZlbG9wbWVudCBtb2RlLCBwYXNzIGFsb25nIHRoZSBjb21wb25lbnQgc3RhY2sgdG8gdGhlIGVycm9yXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBlcnJvckluZm8uY29tcG9uZW50U3RhY2spIHtcbiAgICA7KHN0aXRjaGVkRXJyb3IgYXMgYW55KS5fY29tcG9uZW50U3RhY2sgPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2tcbiAgfVxuICAvLyBTa2lwIGNlcnRhaW4gY3VzdG9tIGVycm9ycyB3aGljaCBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIHJlcG9ydGVkIG9uIGNsaWVudFxuICBpZiAoaXNCYWlsb3V0VG9DU1JFcnJvcihjYXVzZSkpIHJldHVyblxuXG4gIHJlcG9ydEdsb2JhbEVycm9yKHN0aXRjaGVkRXJyb3IpXG59XG4iXSwibmFtZXMiOlsib25SZWNvdmVyYWJsZUVycm9yIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjYXVzZSIsImlzRXJyb3IiLCJzdGl0Y2hlZEVycm9yIiwiZ2V0UmVhY3RTdGl0Y2hlZEVycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29tcG9uZW50U3RhY2siLCJfY29tcG9uZW50U3RhY2siLCJpc0JhaWxvdXRUb0NTUkVycm9yIiwicmVwb3J0R2xvYmFsRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PathParamsContext: function() {\n        return PathParamsContext;\n    },\n    PathnameContext: function() {\n        return PathnameContext;\n    },\n    SearchParamsContext: function() {\n        return SearchParamsContext;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst SearchParamsContext = (0, _react.createContext)(null);\nconst PathnameContext = (0, _react.createContext)(null);\nconst PathParamsContext = (0, _react.createContext)(null);\nif (true) {\n    SearchParamsContext.displayName = 'SearchParamsContext';\n    PathnameContext.displayName = 'PathnameContext';\n    PathParamsContext.displayName = 'PathParamsContext';\n} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFPYUEsaUJBQWlCO2VBQWpCQTs7SUFEQUMsZUFBZTtlQUFmQTs7SUFEQUMsbUJBQW1CO2VBQW5CQTs7O21DQUhpQjtBQUd2QixNQUFNQSxzQkFBc0JDLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQXNDO0FBQ2xFLE1BQU1GLGtCQUFrQkUsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFBNkI7QUFDckQsTUFBTUgsb0JBQW9CRyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFBQSxFQUE2QjtBQUU5RCxJQUFJQyxJQUFvQixFQUFtQjtJQUN6Q0Ysb0JBQW9CSyxXQUFXLEdBQUc7SUFDbENOLGdCQUFnQk0sV0FBVyxHQUFHO0lBQzlCUCxrQkFBa0JPLFdBQVcsR0FBRztBQUNsQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtaWtpX1xcc3JjXFxzaGFyZWRcXGxpYlxcaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuXG5leHBvcnQgY29uc3QgU2VhcmNoUGFyYW1zQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VVJMU2VhcmNoUGFyYW1zIHwgbnVsbD4obnVsbClcbmV4cG9ydCBjb25zdCBQYXRobmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PHN0cmluZyB8IG51bGw+KG51bGwpXG5leHBvcnQgY29uc3QgUGF0aFBhcmFtc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFBhcmFtcyB8IG51bGw+KG51bGwpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFNlYXJjaFBhcmFtc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnU2VhcmNoUGFyYW1zQ29udGV4dCdcbiAgUGF0aG5hbWVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1BhdGhuYW1lQ29udGV4dCdcbiAgUGF0aFBhcmFtc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnUGF0aFBhcmFtc0NvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiUGF0aFBhcmFtc0NvbnRleHQiLCJQYXRobmFtZUNvbnRleHQiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\n"));

/***/ })

});